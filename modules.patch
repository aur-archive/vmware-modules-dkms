From 65e43ea1363a7fa6c1be8a1ffba3abb768584bd3 Mon Sep 17 00:00:00 2001
From: Adrian Bacircea <adrian.bacircea@gmail.com>
Date: Sat, 16 Nov 2013 12:47:00 +0200
Subject: [PATCH 01/10] Updated sources for linux 3.12 kernel

---
 vmblock-only/linux/control.c |  13 ++-
 vmblock-only/linux/file.c    |  21 +++-
 vmblock-only/linux/inode.c   |  15 ++-
 vmmon-only/linux/hostif.c    | 227 ++++++++++++++++++++++---------------------
 vmnet-only/bridge.c          |  60 +++++++++++-
 vmnet-only/driver.c          |  61 ++++++++++++
 vmnet-only/hub.c             | 103 ++++++++++++--------
 vmnet-only/netif.c           |  60 ++++++++++++
 vmnet-only/procfs.c          |  59 +++++++++++
 vmnet-only/userif.c          |  69 ++++++++++++-
 vmnet-only/vnetInt.h         |  15 +++
 11 files changed, 541 insertions(+), 162 deletions(-)

diff --git a/vmblock-only/linux/control.c b/vmblock-only/linux/control.c
index 79716bd..579fb10 100644
--- a/vmblock-only/linux/control.c
+++ b/vmblock-only/linux/control.c
@@ -208,17 +208,26 @@ SetupProcDevice(void)
    VMBlockSetProcEntryOwner(controlProcMountpoint);
 
    /* Create /proc/fs/vmblock/dev */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10)
+   controlProcEntry = proc_create(VMBLOCK_CONTROL_DEVNAME,
+                                  VMBLOCK_CONTROL_MODE,
+                                  controlProcDirEntry,
+                                  &ControlFileOps);
+#else
    controlProcEntry = create_proc_entry(VMBLOCK_CONTROL_DEVNAME,
                                         VMBLOCK_CONTROL_MODE,
                                         controlProcDirEntry);
-   if (!controlProcEntry) {
+#endif
+   if (controlProcEntry == NULL) {
       Warning("SetupProcDevice: could not create " VMBLOCK_DEVICE "\n");
       remove_proc_entry(VMBLOCK_CONTROL_MOUNTPOINT, controlProcDirEntry);
       remove_proc_entry(VMBLOCK_CONTROL_PROC_DIRNAME, NULL);
       return -EINVAL;
    }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
    controlProcEntry->proc_fops = &ControlFileOps;
+#endif
    return 0;
 }
 
@@ -293,7 +302,7 @@ ExecuteBlockOp(const char __user *buf,                // IN: buffer with name
 
    retval = i < 0 ? -EINVAL : blockOp(name, blocker);
 
-   putname(name);
+   __putname(name);
 
    return retval;
 }
diff --git a/vmblock-only/linux/file.c b/vmblock-only/linux/file.c
index d7ac1f6..2e42034 100644
--- a/vmblock-only/linux/file.c
+++ b/vmblock-only/linux/file.c
@@ -38,6 +38,7 @@ typedef u64 inode_num_t;
 typedef ino_t inode_num_t;
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11)
 /* Specifically for our filldir_t callback */
 typedef struct FilldirInfo {
    filldir_t filldir;
@@ -76,7 +77,7 @@ Filldir(void *buf,              // IN: Dirent buffer passed from FileOpReaddir
    /* Specify DT_LNK regardless */
    return info->filldir(info->dirent, name, namelen, offset, ino, DT_LNK);
 }
-
+#endif
 
 /* File operations */
 
@@ -166,11 +167,17 @@ FileOpOpen(struct inode *inode,  // IN
 
 static int
 FileOpReaddir(struct file *file,  // IN
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11)
               void *dirent,       // IN
               filldir_t filldir)  // IN
+#else
+              struct dir_context* ctx) //IN
+#endif
 {
    int ret;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11)
    FilldirInfo info;
+#endif
    struct file *actualFile;
 
    if (!file) {
@@ -184,12 +191,20 @@ FileOpReaddir(struct file *file,  // IN
       return -EINVAL;
    }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11)
    info.filldir = filldir;
    info.dirent = dirent;
 
    actualFile->f_pos = file->f_pos;
    ret = vfs_readdir(actualFile, Filldir, &info);
    file->f_pos = actualFile->f_pos;
+#else
+   /* Ricky Wong Yung Fei:
+    * Manipulation of pos is now handled internally by iterate_dir().
+    */
+   ret = iterate_dir(actualFile, ctx);
+#endif
+
 
    return ret;
 }
@@ -237,7 +252,11 @@ FileOpRelease(struct inode *inode, // IN
 
 
 struct file_operations RootFileOps = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11)
    .readdir = FileOpReaddir,
+#else
+   .iterate = FileOpReaddir,
+#endif
    .open    = FileOpOpen,
    .release = FileOpRelease,
 };
diff --git a/vmblock-only/linux/inode.c b/vmblock-only/linux/inode.c
index 098c94c..cf2ed00 100644
--- a/vmblock-only/linux/inode.c
+++ b/vmblock-only/linux/inode.c
@@ -36,7 +36,12 @@
 
 /* Inode operations */
 static struct dentry *InodeOpLookup(struct inode *dir,
-                                    struct dentry *dentry, struct nameidata *nd);
+                                    struct dentry *dentry,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,12)
+                                    struct nameidata *nd);
+#else
+                                    unsigned int flags);
+#endif
 static int InodeOpReadlink(struct dentry *dentry, char __user *buffer, int buflen);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
 static void *InodeOpFollowlink(struct dentry *dentry, struct nameidata *nd);
@@ -75,7 +80,11 @@ static struct inode_operations LinkInodeOps = {
 static struct dentry *
 InodeOpLookup(struct inode *dir,      // IN: parent directory's inode
               struct dentry *dentry,  // IN: dentry to lookup
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,12)
               struct nameidata *nd)   // IN: lookup intent and information
+#else
+              unsigned int flags)     // IN: lookup intent and information
+#endif
 {
    char *filename;
    struct inode *inode;
@@ -221,7 +230,11 @@ InodeOpFollowlink(struct dentry *dentry,  // IN : dentry of symlink
       goto out;
    }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,12)
    ret = vfs_follow_link(nd, iinfo->name);
+#else
+   nd_set_link(nd, iinfo->name);
+#endif
 
 out:
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
diff --git a/vmmon-only/linux/hostif.c b/vmmon-only/linux/hostif.c
index fcf782d..9658ce8 100644
--- a/vmmon-only/linux/hostif.c
+++ b/vmmon-only/linux/hostif.c
@@ -78,6 +78,7 @@
 #include <linux/kthread.h>
 #include <linux/wait.h>
 
+#include <asm/apic.h>
 
 #include "vmware.h"
 #include "x86apic.h"
@@ -423,7 +424,7 @@ HostIF_CancelWaitForThreads(VMDriver *vm,     // IN:
  * HostIF_WakeUpYielders --
  *
  *      Wakeup vCPUs that are waiting for the current vCPU.
- *      
+ *
  * Results:
  *      The requested vCPUs are nudged if they are sleeping due to
  *      Vmx86_YieldToSet.
@@ -490,7 +491,7 @@ HostIF_InitGlobalLock(void)
  *      None
  *
  * Side effects:
- *      Should be a very low contention lock. 
+ *      Should be a very low contention lock.
  *      The current thread is rescheduled if the lock is busy.
  *
  *-----------------------------------------------------------------------------
@@ -533,7 +534,7 @@ HostIF_GlobalUnlock(int callerID) // IN
  * HostIF_GlobalLockIsHeld --
  *
  *      Determine if the global lock is held by the current thread.
- * 
+ *
  * Results:
  *      TRUE if yes
  *      FALSE if no
@@ -563,7 +564,7 @@ HostIF_GlobalLockIsHeld(void)
  *      None
  *
  * Side effects:
- *      Should be a very low contention lock. 
+ *      Should be a very low contention lock.
  *      The current thread is rescheduled if the lock is busy.
  *
  *-----------------------------------------------------------------------------
@@ -698,7 +699,7 @@ static int
 HostIFHostMemInit(VMDriver *vm)  // IN:
 {
    VMHost *vmh = vm->vmhost;
-   
+
    vmh->lockedPages = PhysTrack_Alloc(vm);
    if (!vmh->lockedPages) {
       return -1;
@@ -740,7 +741,7 @@ HostIFHostMemCleanup(VMDriver *vm)  // IN:
 
    HostIF_VMLock(vm, 32); // Debug version of PhysTrack wants VM's lock.
    if (vmh->lockedPages) {
-      for (mpn = 0; 
+      for (mpn = 0;
            INVALID_MPN != (mpn = PhysTrack_GetNext(vmh->lockedPages, mpn));) {
          HOST_UNLOCK_PFN_BYMPN(vm, mpn);
       }
@@ -749,7 +750,7 @@ HostIFHostMemCleanup(VMDriver *vm)  // IN:
    }
 
    if (vmh->AWEPages) {
-      for (mpn = 0; 
+      for (mpn = 0;
            INVALID_MPN != (mpn = PhysTrack_GetNext(vmh->AWEPages, mpn));) {
 	 PhysTrack_Remove(vmh->AWEPages, mpn);
          put_page(pfn_to_page(mpn));
@@ -766,7 +767,7 @@ HostIFHostMemCleanup(VMDriver *vm)  // IN:
  *
  * HostIF_AllocMachinePage --
  *
- *      Alloc non-swappable memory page. The page is not billed to  
+ *      Alloc non-swappable memory page. The page is not billed to
  *      a particular VM. Preferably the page should not be mapped into
  *      the kernel addresss space.
  *
@@ -793,8 +794,8 @@ HostIF_AllocMachinePage(void)
  *
  * HostIF_FreeMachinePage --
  *
- *      Free an anonymous machine page allocated by 
- *      HostIF_AllocMachinePage().  This page is not tracked in any 
+ *      Free an anonymous machine page allocated by
+ *      HostIF_AllocMachinePage().  This page is not tracked in any
  *      phystracker.
  *
  * Results:
@@ -835,7 +836,7 @@ HostIF_FreeMachinePage(MPN mpn)  // IN:
 
 int
 HostIF_AllocLockedPages(VMDriver *vm,	     // IN: VM instance pointer
-			VA64 addr,	     // OUT: pointer to user or kernel buffer for MPNs 
+			VA64 addr,	     // OUT: pointer to user or kernel buffer for MPNs
 			unsigned numPages,   // IN: number of pages to allocate
 			Bool kernelMPNBuffer)// IN: is the MPN buffer in kernel or user address space?
 {
@@ -850,7 +851,7 @@ HostIF_AllocLockedPages(VMDriver *vm,	     // IN: VM instance pointer
    for (cnt = 0; cnt < numPages; cnt++) {
       struct page* pg;
       MPN32 mpn;
-      
+
       pg = alloc_page(GFP_HIGHUSER);
       if (!pg) {
          err = -ENOMEM;
@@ -895,16 +896,16 @@ HostIF_AllocLockedPages(VMDriver *vm,	     // IN: VM instance pointer
 
 int
 HostIF_FreeLockedPages(VMDriver *vm,	     // IN: VM instance pointer
-		       VA64 addr,            // IN: user or kernel array of MPNs 
+		       VA64 addr,            // IN: user or kernel array of MPNs
 		       unsigned numPages,    // IN: number of pages to free
 		       Bool kernelMPNBuffer) // IN: is the MPN buffer in kernel or user address space?
 {
    MPN32 const *pmpn = VA64ToPtr(addr);
    VMHost *vmh = vm->vmhost;
    unsigned int cnt;
-   struct page *pg; 
+   struct page *pg;
    MPN32 mpns[64];
-      
+
    if (!vmh || !vmh->AWEPages) {
       return -EINVAL;
    }
@@ -940,7 +941,7 @@ HostIF_FreeLockedPages(VMDriver *vm,	     // IN: VM instance pointer
       }
    }
 
-   for (cnt = 0; cnt < numPages; cnt++) {     
+   for (cnt = 0; cnt < numPages; cnt++) {
       pg = pfn_to_page(pmpn[cnt]);
       PhysTrack_Remove(vmh->AWEPages, pmpn[cnt]);
       __free_page(pg);
@@ -997,7 +998,7 @@ HostIF_Init(VMDriver *vm)  // IN:
  *      Lookup the MPN of a locked user page by user VA.
  *
  * Results:
- *      Returned page is a valid MPN, zero on error. 
+ *      Returned page is a valid MPN, zero on error.
  *
  * Side effects:
  *     None
@@ -1005,7 +1006,7 @@ HostIF_Init(VMDriver *vm)  // IN:
  *------------------------------------------------------------------------------
  */
 
-MPN 
+MPN
 HostIF_LookupUserMPN(VMDriver *vm, // IN: VMDriver
                      VA64 uAddr)   // IN: user VA of the page
 {
@@ -1041,19 +1042,19 @@ HostIF_LookupUserMPN(VMDriver *vm, // IN: VMDriver
 	    get_user(c, (char *)uvAddr);
 	    mpn = PgtblVa2MPN((VA)uvAddr);
 	    if (mpn == entryPtr->mpn) {
-#ifdef VMX86_DEBUG	    
+#ifdef VMX86_DEBUG
 	       printk(KERN_DEBUG "Page %p disappeared from %s(%u)... "
-                      "now back at %#x\n", 
+                      "now back at %#x\n",
 		      uvAddr, current->comm, current->pid, mpn);
 #endif
 	    } else if (mpn != INVALID_MPN) {
 	       printk(KERN_DEBUG "Page %p disappeared from %s(%u)... "
-                      "now back at %#x (old=%#x)\n", uvAddr, current->comm, 
+                      "now back at %#x (old=%#x)\n", uvAddr, current->comm,
                       current->pid, mpn, entryPtr->mpn);
 	       mpn = INVALID_MPN;
 	    } else {
 	       printk(KERN_DEBUG "Page %p disappeared from %s(%u)... "
-                      "and is lost (old=%#x)\n", uvAddr, current->comm, 
+                      "and is lost (old=%#x)\n", uvAddr, current->comm,
                       current->pid, entryPtr->mpn);
 	       mpn = entryPtr->mpn;
 	    }
@@ -1075,7 +1076,7 @@ HostIF_LookupUserMPN(VMDriver *vm, // IN: VMDriver
  * Results:
  *      prevents INTR #0x2d (IRQ 13) from being generated --
  *      assume that Int16 works for interrupt reporting
- *      
+ *
  *
  * Side effects:
  *      PIC
@@ -1090,7 +1091,7 @@ HostIF_InitFP(VMDriver *vm)  // IN:
 
    uint8 val = inb(0xA1);
 
-   if (!(val & mask)) { 
+   if (!(val & mask)) {
       val = val | mask;
       outb(val, 0xA1);
    }
@@ -1106,7 +1107,7 @@ HostIF_InitFP(VMDriver *vm)  // IN:
  *      If ppages is NULL, pages are only marked as dirty.
  *
  * Results:
- *      Zero on success, non-zero on failure. 
+ *      Zero on success, non-zero on failure.
  *
  * Side effects:
  *      None
@@ -1136,10 +1137,10 @@ HostIFGetUserPages(void *uvAddr,          // IN
  *
  * HostIF_LookupLargeMPN --
  *
- *      Gets the first MPN of a hugetlb page. 
+ *      Gets the first MPN of a hugetlb page.
  *
  * Results:
- *      The MPN or PAGE_LOCK_FAILED on an error. 
+ *      The MPN or PAGE_LOCK_FAILED on an error.
  *
  * Side effects:
  *      None.
@@ -1170,11 +1171,11 @@ HostIF_LookupLargeMPN(void *uvAddr)  // IN: user VA of the page
  *
  * HostIF_IsLockedByMPN --
  *
- *      Checks if mpn was locked using allowMultipleMPNsPerVA.  
+ *      Checks if mpn was locked using allowMultipleMPNsPerVA.
  *
  * Results:
  *      TRUE if mpn is present in the physTracker.
- *      
+ *
  *
  * Side effects:
  *     None.
@@ -1195,14 +1196,14 @@ HostIF_IsLockedByMPN(VMDriver *vm,  // IN:
  *
  * HostIF_LockPage --
  *
- *      Lockup the MPN of an pinned user-level address space 
+ *      Lockup the MPN of an pinned user-level address space
  *
  * Results:
- *      The MPN or zero on an error. 
+ *      The MPN or zero on an error.
  *
  * Side effects:
  *      Adds the page to the MemTracker,
- *	if allowMultipleMPNsPerVA then the page is added 
+ *	if allowMultipleMPNsPerVA then the page is added
  *      to the VM's PhysTracker.
  *
  *-----------------------------------------------------------------------------
@@ -1222,7 +1223,7 @@ HostIF_LockPage(VMDriver *vm,		     // IN: VMDriver
    vpn = PTR_2_VPN(uvAddr);
    if (!allowMultipleMPNsPerVA) {
       entryPtr = MemTrack_LookupVPN(vm->memtracker, vpn);
-      
+
       /*
        * Already tracked and locked
        */
@@ -1243,7 +1244,7 @@ HostIF_LockPage(VMDriver *vm,		     // IN: VMDriver
        */
 
       struct PhysTracker* const pt = vm->vmhost->lockedPages;
-      
+
       if (PhysTrack_Test(pt, mpn)) {
 	 put_page(page);
 
@@ -1264,7 +1265,7 @@ HostIF_LockPage(VMDriver *vm,		     // IN: VMDriver
 	    return PAGE_LOCK_MEMTRACKER_ERROR;
 	 }
       } else {
-	 entryPtr->mpn = mpn;  
+	 entryPtr->mpn = mpn;
       }
    }
 
@@ -1281,7 +1282,7 @@ HostIF_LockPage(VMDriver *vm,		     // IN: VMDriver
  *
  * Results:
  *      0 if successful, otherwise non-zero
- *      
+ *
  * Side effects:
  *     None
  *
@@ -1298,7 +1299,7 @@ HostIF_UnlockPage(VMDriver *vm,  // IN:
 
    vpn = VA_2_VPN((VA)addr);
    e = MemTrack_LookupVPN(vm->memtracker, vpn);
-    
+
    if (e == NULL) {
       return PAGE_UNLOCK_NOT_TRACKED;
    }
@@ -1343,7 +1344,7 @@ HostIF_UnlockPageByMPN(VMDriver *vm, // IN: VMDriver
    {
       void *va = VA64ToPtr(uAddr);
       MemTrackEntry *e;
-      
+
       /*
        * Verify for debugging that VA and MPN make sense.
        * PgtblVa2MPN() can fail under high memory pressure.
@@ -1360,7 +1361,7 @@ HostIF_UnlockPageByMPN(VMDriver *vm, // IN: VMDriver
       }
 
       /*
-       * Verify that this MPN was locked with 
+       * Verify that this MPN was locked with
        * HostIF_LockPage(allowMultipleMPNsPerVA = TRUE).
        * That means that this MPN should not be in the MemTracker.
        */
@@ -1373,7 +1374,7 @@ HostIF_UnlockPageByMPN(VMDriver *vm, // IN: VMDriver
 	 return PAGE_UNLOCK_MISMATCHED_TYPE;
       }
    }
-#endif 
+#endif
 
    HOST_UNLOCK_PFN_BYMPN(vm, mpn);
 
@@ -1381,7 +1382,7 @@ HostIF_UnlockPageByMPN(VMDriver *vm, // IN: VMDriver
 }
 
 
-static void 
+static void
 UnlockEntry(void *clientData,         // IN:
             MemTrackEntry *entryPtr)  // IN:
 {
@@ -1444,11 +1445,11 @@ HostIF_FreeAllResources(VMDriver *vm) // IN
  *
  * HostIF_AllocKernelMem
  *
- *      Allocate some kernel memory for the driver. 
+ *      Allocate some kernel memory for the driver.
  *
  * Results:
- *      The address allocated or NULL on error. 
- *      
+ *      The address allocated or NULL on error.
+ *
  *
  * Side effects:
  *      memory is malloced
@@ -1460,8 +1461,8 @@ HostIF_AllocKernelMem(size_t size,  // IN:
                       int wired)    // IN:
 {
    void * ptr = kmalloc(size, GFP_KERNEL);
-   
-   if (ptr == NULL) { 
+
+   if (ptr == NULL) {
       Warning("%s failed (size=%p)\n", __func__, (void*)size);
    }
 
@@ -1489,7 +1490,7 @@ void *
 HostIF_AllocPage(void)
 {
    VA kvAddr;
-   
+
    kvAddr = __get_free_page(GFP_KERNEL);
    if (kvAddr == 0) {
       Warning("%s: __get_free_page() failed\n", __func__);
@@ -1504,7 +1505,7 @@ HostIF_AllocPage(void)
  *
  * HostIF_FreeKernelMem
  *
- *      Free kernel memory allocated for the driver. 
+ *      Free kernel memory allocated for the driver.
  *
  * Results:
  *      None.
@@ -1573,7 +1574,7 @@ HostIF_IsAnonPage(VMDriver *vm,      // IN: VM instance pointer
  *      from the kernel without causing the host to die or to be really upset.
  *
  * Results:
- *	The maximum number of pages that can be locked. 
+ *	The maximum number of pages that can be locked.
  *
  * Side effects:
  *      none
@@ -1601,9 +1602,9 @@ HostIF_EstimateLockedPageLimit(const VMDriver* vm,		  // IN
     * Use the memory information linux exports as of late for a more
     * precise estimate of locked memory.  All kernel page-related structures
     * (slab, pagetable) are as good as locked.  Unevictable includes things
-    * that are explicitly marked as such (like mlock()).  Huge pages are 
-    * also as good as locked, since we don't use them.  Lastly, without 
-    * available swap, anonymous pages become locked in memory as well. 
+    * that are explicitly marked as such (like mlock()).  Huge pages are
+    * also as good as locked, since we don't use them.  Lastly, without
+    * available swap, anonymous pages become locked in memory as well.
     */
 
    unsigned int forHost;
@@ -1614,11 +1615,11 @@ HostIF_EstimateLockedPageLimit(const VMDriver* vm,		  // IN
                               global_page_state(NR_SLAB_UNRECLAIMABLE) +
                               global_page_state(NR_UNEVICTABLE) +
                               hugePages + reservedPages;
-   unsigned int anonPages = global_page_state(NR_ANON_PAGES); 
+   unsigned int anonPages = global_page_state(NR_ANON_PAGES);
    unsigned int swapPages = BYTES_2_PAGES(linuxState.swapSize);
 
    if (anonPages > swapPages) {
-      lockedPages += anonPages - swapPages; 
+      lockedPages += anonPages - swapPages;
    }
    forHost = lockedPages + LOCKED_PAGE_SLACK;
    if (forHost > totalPhysicalPages) {
@@ -1663,7 +1664,7 @@ HostIF_Wait(unsigned int timeoutMs)
  *----------------------------------------------------------------------
  */
 
-void 
+void
 HostIF_WaitForFreePages(unsigned int timeoutMs)  // IN:
 {
    static unsigned count;
@@ -1688,20 +1689,20 @@ HostIF_WaitForFreePages(unsigned int timeoutMs)  // IN:
  *      timeofday to have small drift (due to NTP rate correction, etc).
  *      We handle this by rebasing the jiffies based monotonic clock
  *      every second (see HostIFUptimeResyncMono).
- *      
+ *
  * Results:
  *      The uptime, in units of UPTIME_FREQ.  Also returns the jiffies
  *      value that was used in the monotonic time calculation.
  *
  * Side effects:
- *      May reset the uptime base in the case gettimeofday warp was 
+ *      May reset the uptime base in the case gettimeofday warp was
  *      detected.
  *
  *----------------------------------------------------------------------
  */
 
 static uint64
-HostIFReadUptimeWork(unsigned long *j)  // OUT: current jiffies 
+HostIFReadUptimeWork(unsigned long *j)  // OUT: current jiffies
 {
    struct timeval tv;
    uint64 monotime, uptime, upBase, monoBase;
@@ -1723,14 +1724,14 @@ HostIFReadUptimeWork(unsigned long *j)  // OUT: current jiffies
 
    do_gettimeofday(&tv);
    upBase = Atomic_Read64(&uptimeState.uptimeBase);
-   
+
    monotime = (uint64)(jifs - jifBase) * (UPTIME_FREQ / HZ);
    monotime += monoBase;
 
    uptime = tv.tv_usec * (UPTIME_FREQ / 1000000) + tv.tv_sec * UPTIME_FREQ;
    uptime += upBase;
-   
-   /* 
+
+   /*
     * Use the jiffies based monotonic time to sanity check gettimeofday.
     * If they differ by more than one second, assume the time of day has
     * been warped, and use the jiffies time to undo (most of) the warp.
@@ -1742,7 +1743,7 @@ HostIFReadUptimeWork(unsigned long *j)  // OUT: current jiffies
       uint64 newUpBase = monotime - (uptime - upBase);
 
       attempts++;
-      if (!Atomic_CMPXCHG64(&uptimeState.uptimeBase, &upBase, &newUpBase) && 
+      if (!Atomic_CMPXCHG64(&uptimeState.uptimeBase, &upBase, &newUpBase) &&
           attempts < 5) {
          /* Another thread updated uptimeBase.  Recalculate uptime. */
          goto retry;
@@ -1783,7 +1784,7 @@ HostIFUptimeResyncMono(unsigned long data)  // IN: ignored
    unsigned long jifs;
    uintptr_t flags;
 
-   /* 
+   /*
     * Read the uptime and the corresponding jiffies value.  This will
     * also correct the uptime (which is based on time of day) if needed
     * before we rebase monotonic time (which is based on jiffies).
@@ -1791,7 +1792,7 @@ HostIFUptimeResyncMono(unsigned long data)  // IN: ignored
 
    uint64 uptime = HostIFReadUptimeWork(&jifs);
 
-   /* 
+   /*
     * Every second, recalculate monoBase and jiffiesBase to squash small
     * drift between gettimeofday and jiffies.  Also, this prevents
     * (jiffies - jiffiesBase) wrap on 32-bits.
@@ -1836,8 +1837,8 @@ HostIF_InitUptime(void)
 
    uptimeState.jiffiesBase = jiffies;
    do_gettimeofday(&tv);
-   Atomic_Write64(&uptimeState.uptimeBase, 
-                  -(tv.tv_usec * (UPTIME_FREQ / 1000000) + 
+   Atomic_Write64(&uptimeState.uptimeBase,
+                  -(tv.tv_usec * (UPTIME_FREQ / 1000000) +
                     tv.tv_sec * UPTIME_FREQ));
 
    init_timer(&uptimeState.timer);
@@ -1965,7 +1966,7 @@ HostIF_CopyFromUser(void *dst,	      // OUT
  *-----------------------------------------------------------------------------
  */
 
-int 
+int
 HostIF_CopyToUser(void *dst,	    // OUT
                   const void *src,  // IN
                   unsigned int len) // IN
@@ -1978,15 +1979,15 @@ HostIF_CopyToUser(void *dst,	    // OUT
  *-----------------------------------------------------------------------------
  *
  * HostIF_MapCrossPage --
- *    
- *    Obtain kernel pointer to crosspage. 
  *
- *    We must return a VA that is obtained through a kernel mapping, so that 
+ *    Obtain kernel pointer to crosspage.
+ *
+ *    We must return a VA that is obtained through a kernel mapping, so that
  *    the mapping never goes away (see bug 29753).
  *
- *    However, the LA corresponding to that VA must not overlap with the 
- *    monitor (see bug 32922). The userland code ensures that by only 
- *    allocating cross pages from low memory. For those pages, the kernel 
+ *    However, the LA corresponding to that VA must not overlap with the
+ *    monitor (see bug 32922). The userland code ensures that by only
+ *    allocating cross pages from low memory. For those pages, the kernel
  *    uses a permanent mapping, instead of a temporary one with a high LA.
  *
  * Results:
@@ -2178,7 +2179,7 @@ HostIF_VMLock(VMDriver *vm, // IN
  *      None
  *
  * Side effects:
- *      Can wake up the thread blocked on this lock. 
+ *      Can wake up the thread blocked on this lock.
  *
  *-----------------------------------------------------------------------------
  */
@@ -2201,7 +2202,7 @@ HostIF_VMUnlock(VMDriver *vm, // IN
  * HostIF_VMLockIsHeld --
  *
  *      Determine if the per-VM lock is held by the current thread.
- * 
+ *
  * Results:
  *      TRUE if yes
  *      FALSE if no
@@ -2257,14 +2258,14 @@ HostIF_VMLockIsHeld(VMDriver *vm) // IN
  *
  *----------------------------------------------------------------------
  */
- 
+
 static Bool
 isVAReadable(VA r)  // IN:
 {
    mm_segment_t old_fs;
    uint32 dummy;
    int ret;
-   
+
    old_fs = get_fs();
    set_fs(get_ds());
    r = APICR_TO_ADDR(r, APICR_VERSION);
@@ -2339,7 +2340,7 @@ ProbeAPIC(VMDriver *vm,   // IN/OUT: driver state
 	  Bool setVMPtr)  // IN: set a pointer to the APIC's virtual address
 {
    MA ma = APIC_GetMA();
-   
+
    if (ma == (MA)-1) {
       return FALSE;
    }
@@ -2388,7 +2389,7 @@ HostIF_APICInit(VMDriver *vm,   // IN:
    static Bool apicIPILogged = FALSE;
    VA kAddr;
 
-   /* 
+   /*
     * All Linux versions below 3.0.0 that we support have the RESCHEDULE_VECTOR,
     * which is noted to be a NOP on them.  2.6.24 starts accumulating a counter
     * for the reschedule vector, so any borrowed RESCHEDULE_VECTORs we leak
@@ -2447,7 +2448,7 @@ HostIF_APICInit(VMDriver *vm,   // IN:
  *    Perform the semaphore wait (P) operation, possibly blocking.
  *
  * Result:
- *    1 (which equals MX_WAITNORMAL) if success, 
+ *    1 (which equals MX_WAITNORMAL) if success,
  *    negated error code otherwise.
  *
  * Side-effects:
@@ -2456,7 +2457,7 @@ HostIF_APICInit(VMDriver *vm,   // IN:
  *-----------------------------------------------------------------------------
  */
 
-int   
+int
 HostIF_SemaphoreWait(VMDriver *vm,   // IN:
                      Vcpuid vcpuid,  // IN:
                      uint32 *args)   // IN:
@@ -2479,7 +2480,7 @@ HostIF_SemaphoreWait(VMDriver *vm,   // IN:
    {
       struct poll_wqueues table;
       unsigned int mask;
-      
+
       poll_initwait(&table);
       current->state = TASK_INTERRUPTIBLE;
       mask = file->f_op->poll(file, &table.pt);
@@ -2554,7 +2555,7 @@ HostIF_SemaphoreWait(VMDriver *vm,   // IN:
  *-----------------------------------------------------------------------------
  */
 
-void 
+void
 HostIF_SemaphoreForceWakeup(VMDriver *vm,   // IN:
                             Vcpuid vcpuid)  // IN:
 {
@@ -2854,8 +2855,8 @@ HostIF_CallOnEachCPU(void (*func)(void*), // IN: function to call
  *
  * HostIF_ReadPage --
  *
- *      puts the content of a machine page into a kernel or user mode 
- *      buffer. 
+ *      puts the content of a machine page into a kernel or user mode
+ *      buffer.
  *
  * Results:
  *	0 on success
@@ -2867,7 +2868,7 @@ HostIF_CallOnEachCPU(void (*func)(void*), // IN: function to call
  *----------------------------------------------------------------------
  */
 
-int 
+int
 HostIF_ReadPage(MPN mpn,	    // MPN of the page
 		VA64 addr,	    // buffer for data
 		Bool kernelBuffer)  // is the buffer in kernel space?
@@ -2875,17 +2876,17 @@ HostIF_ReadPage(MPN mpn,	    // MPN of the page
    void *buf = VA64ToPtr(addr);
    int ret = 0;
    const void* ptr;
-   struct page* page; 
-   
+   struct page* page;
+
    if (mpn == INVALID_MPN) {
       return -EFAULT;
-   }   
+   }
    page = pfn_to_page(mpn);
    ptr = kmap(page);
    if (ptr == NULL) {
       return -ENOMEM;
    }
-   
+
    if (kernelBuffer) {
       memcpy(buf, ptr, PAGE_SIZE);
    } else {
@@ -2902,7 +2903,7 @@ HostIF_ReadPage(MPN mpn,	    // MPN of the page
  *
  * HostIF_WritePage --
  *
- *      Put the content of a kernel or user mode buffer into a machine 
+ *      Put the content of a kernel or user mode buffer into a machine
  *      page.
  *
  * Results:
@@ -2915,7 +2916,7 @@ HostIF_ReadPage(MPN mpn,	    // MPN of the page
  *----------------------------------------------------------------------
  */
 
-int 
+int
 HostIF_WritePage(MPN mpn,	    // MPN of the page
 		 VA64 addr,         // data to write to the page
 		 Bool kernelBuffer) // is the buffer in kernel space?
@@ -2923,17 +2924,17 @@ HostIF_WritePage(MPN mpn,	    // MPN of the page
    void const *buf = VA64ToPtr(addr);
    int ret = 0;
    void* ptr;
-   struct page* page;  
+   struct page* page;
 
    if (mpn == INVALID_MPN) {
       return -EFAULT;
-   }   
+   }
    page = pfn_to_page(mpn);
    ptr = kmap(page);
    if (ptr == NULL) {
       return -ENOMEM;
    }
-   
+
    if (kernelBuffer) {
       memcpy(ptr, buf, PAGE_SIZE);
    } else {
@@ -2963,10 +2964,10 @@ HostIF_WritePage(MPN mpn,	    // MPN of the page
  *----------------------------------------------------------------------
  */
 
-int 
+int
 HostIF_GetLockedPageList(VMDriver* vm,          // IN: VM instance pointer
 			 VA64 uAddr,            // OUT: user mode buffer for MPNs
-		         unsigned int numPages) // IN: size of the buffer in MPNs 
+		         unsigned int numPages) // IN: size of the buffer in MPNs
 {
    MPN32 *mpns = VA64ToPtr(uAddr);
    MPN mpn;
@@ -3007,7 +3008,7 @@ HostIF_GetLockedPageList(VMDriver* vm,          // IN: VM instance pointer
  * Side effects:
  *    None.
  *
- *---------------------------------------------------------------------- 
+ *----------------------------------------------------------------------
  */
 
 uint32
@@ -3025,18 +3026,18 @@ HostIF_GetCurrentPCPU(void)
  *
  *      Wake up the fast clock thread.  Can't do this from the timer
  *      callback, because it holds locks that the scheduling code
- *      might take. 
+ *      might take.
  *
  * Results:
  *      None.
- *      
+ *
  * Side effects:
  *      None.
  *
  *----------------------------------------------------------------------
  */
 
-static void 
+static void
 HostIFWakeupClockThread(unsigned long data)  //IN:
 {
    wake_up_process(linuxState.fastClockThread);
@@ -3047,7 +3048,7 @@ HostIFWakeupClockThread(unsigned long data)  //IN:
  *----------------------------------------------------------------------
  *
  * HostIFTimerCallback --
- *      
+ *
  *      Schedule a tasklet to wake up the fast clock thread.
  *
  * Results:
@@ -3058,8 +3059,8 @@ HostIFWakeupClockThread(unsigned long data)  //IN:
  *
  *----------------------------------------------------------------------
  */
- 
-static enum hrtimer_restart 
+
+static enum hrtimer_restart
 HostIFTimerCallback(struct hrtimer *timer)  //IN:
 {
    tasklet_schedule(&timerTasklet);
@@ -3072,7 +3073,7 @@ HostIFTimerCallback(struct hrtimer *timer)  //IN:
  *----------------------------------------------------------------------
  *
  * HostIFScheduleHRTimeout --
- *      
+ *
  *      Schedule an hrtimer to wake up the fast clock thread.
  *
  * Results:
@@ -3084,7 +3085,7 @@ HostIFTimerCallback(struct hrtimer *timer)  //IN:
  *----------------------------------------------------------------------
  */
 
-static void 
+static void
 HostIFScheduleHRTimeout(ktime_t *expires)  //IN:
 {
    struct hrtimer t;
@@ -3102,7 +3103,7 @@ HostIFScheduleHRTimeout(ktime_t *expires)  //IN:
    if (hrtimer_active(&t)) {
       schedule();
    }
-   
+
    hrtimer_cancel(&t);
    __set_current_state(TASK_RUNNING);
 }
@@ -3125,7 +3126,7 @@ HostIFScheduleHRTimeout(ktime_t *expires)  //IN:
  * Side effects:
  *    none.
  *
- *---------------------------------------------------------------------- 
+ *----------------------------------------------------------------------
  */
 
 static long
@@ -3170,7 +3171,7 @@ HostIFDoIoctl(struct file *filp,
  */
 
 int
-HostIFStartTimer(Bool rateChanged,  //IN: Did rate change? 
+HostIFStartTimer(Bool rateChanged,  //IN: Did rate change?
 		 unsigned int rate, //IN: current clock rate
                  struct file *filp) //IN: /dev/rtc descriptor
 {
@@ -3180,14 +3181,14 @@ HostIFStartTimer(Bool rateChanged,  //IN: Did rate change?
    int timerPeriod;
 
    if (rateChanged) {
-      timerPeriod = NSEC_PER_SEC / rate; 
+      timerPeriod = NSEC_PER_SEC / rate;
       expires = ktime_set(0, timerPeriod);
       /*
        * Allow the kernel to expire the timer at its convenience.
        * ppoll() uses 0.1% of the timeout value.  I think we can
        * tolerate 1%.
        */
-          
+
       slack = timerPeriod / 100;
    }
    set_current_state(TASK_INTERRUPTIBLE);
@@ -3533,7 +3534,7 @@ HostIF_MapUserMem(VA addr,                  // IN: User memory virtual address
 
    printk(KERN_DEBUG "%s: p = 0x%p, offset = 0x%p, numPagesNeeded = %"FMTSZ"u,"
           " handleSize = %"FMTSZ"u, mappedAddr = 0x%p\n",
-          __func__, p, (void *)offset, numPagesNeeded, handleSize, mappedAddr); 
+          __func__, p, (void *)offset, numPagesNeeded, handleSize, mappedAddr);
 
    newHandle->numPages = numPagesNeeded;
    newHandle->addr = mappedAddr;
@@ -3569,7 +3570,7 @@ HostIF_UnmapUserMem(VMMappedUserMem *handle) // IN: Handle to mapped memory
    }
 
    printk(KERN_DEBUG "%s: numPages = %"FMTSZ"u, addr = 0x%p\n",
-          __func__, handle->numPages, handle->addr); 
+          __func__, handle->numPages, handle->addr);
 
    if (handle->numPages > 1) {
       vunmap(handle->addr);
diff --git a/vmnet-only/bridge.c b/vmnet-only/bridge.c
index 10eaa41..62d47c0 100644
--- a/vmnet-only/bridge.c
+++ b/vmnet-only/bridge.c
@@ -105,8 +105,10 @@ static Bool VNetBridgeCycleDetect(VNetJack *this, int generation);
 static Bool VNetBridgeIsDeviceWireless(struct net_device *dev);
 static void VNetBridgePortsChanged(VNetJack *this);
 static int  VNetBridgeIsBridged(VNetJack *this);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
 static int  VNetBridgeProcRead(char *page, char **start, off_t off,
                                int count, int *eof, void *data);
+#endif
 static void VNetBridgeComputeHeaderPosIPv6(struct sk_buff *skb);
 static PacketStatus VNetCallSMACFunc(struct SMACState *state,
                                      struct sk_buff **skb, void *startOfData,
@@ -221,6 +223,54 @@ VNetBridgeDevCompatible(VNetBridge *bridge,      // IN: Bridge
    return strcmp(net->name, bridge->name) == 0;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10)
+/*
+ *----------------------------------------------------------------------
+ *
+ * VNetBridgeProcShow --
+ *
+ *      Callback for read operation on this bridge entry in vnets proc fs.
+ *
+ * Results:
+ *      Length of read operation.
+ *
+ * Side effects:
+ *      None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+int
+VNetBridgeProcShow(struct seq_file *seqf, // IN/OUT: buffer to write into
+                   void    *data)   // IN: client data - pointer to bridge
+{
+   VNetBridge *bridge = (VNetBridge*)data;
+
+   if (!bridge) {
+      return 0;
+   }
+
+   VNetPrintPort(&bridge->port, seqf);
+
+   seq_printf(seqf, "dev %s ", bridge->name);
+
+   seq_printf(seqf, "\n");
+
+   return 0;
+}
+
+static int proc_bridge_open(struct inode *inode, struct file *file)
+{
+       return single_open(file, VNetBridgeProcShow, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_bridge_fops = {
+       .open           = proc_bridge_open,
+       .read           = seq_read,
+       .llseek         = seq_lseek,
+       .release        = seq_release,
+};
+#endif
 
 /*
  *----------------------------------------------------------------------
@@ -319,17 +369,24 @@ VNetBridge_Create(const char *devName, // IN:  name of device (e.g., "eth0")
     * Make proc entry for this jack.
     */
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
    retval = VNetProc_MakeEntry(bridge->port.jack.name, S_IFREG,
                                &bridge->port.jack.procEntry);
+#else
+   retval = VNetProc_MakeEntryOps(bridge->port.jack.name, S_IFREG,
+                               &bridge->port.jack.procEntry, &proc_bridge_fops, bridge);
+#endif
    if (retval) {
       if (retval == -ENXIO) {
          bridge->port.jack.procEntry = NULL;
       } else {
          goto out;
       }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
    } else {
       bridge->port.jack.procEntry->read_proc = VNetBridgeProcRead;
       bridge->port.jack.procEntry->data = bridge;
+#endif
    }
 
    /*
@@ -1719,7 +1776,7 @@ VNetBridgeReceiveFromDev(struct sk_buff *skb,         // IN: packet to receive
    return 0;
 }
 
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
 /*
  *----------------------------------------------------------------------
  *
@@ -1761,3 +1818,4 @@ VNetBridgeProcRead(char    *page,   // IN/OUT: buffer to write into
    *eof   = 1;
    return len;
 }
+#endif
diff --git a/vmnet-only/driver.c b/vmnet-only/driver.c
index 2a3b658..157eb05 100644
--- a/vmnet-only/driver.c
+++ b/vmnet-only/driver.c
@@ -1785,6 +1785,7 @@ VNetSetMACUnique(VNetPort *port,            // IN:
  *----------------------------------------------------------------------
  */
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
 int
 VNetPrintJack(const VNetJack *jack, // IN: jack
               char           *buf)  // OUT: info about jack
@@ -1801,6 +1802,20 @@ VNetPrintJack(const VNetJack *jack, // IN: jack
 
    return len;
 }
+#else
+void
+VNetPrintJack(const VNetJack *jack, // IN: jack
+              struct seq_file *seqf)  // OUT: info about jack
+{
+   read_lock(&vnetPeerLock);
+   if (!jack->peer) {
+      seq_printf(seqf, "connected not ");
+   } else {
+      seq_printf(seqf, "connected %s ", jack->peer->name);
+   }
+   read_unlock(&vnetPeerLock);
+}
+#endif
 
 
 /*
@@ -1819,6 +1834,7 @@ VNetPrintJack(const VNetJack *jack, // IN: jack
  *----------------------------------------------------------------------
  */
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
 int
 VNetPrintPort(const VNetPort *port, // IN: port
               char           *buf)  // OUT: info about port
@@ -1866,6 +1882,51 @@ VNetPrintPort(const VNetPort *port, // IN: port
 
    return len;
 }
+#else
+void
+VNetPrintPort(const VNetPort *port, // IN: port
+              struct seq_file *seqf)  // OUT: info about port
+{
+   VNetPrintJack(&port->jack, seqf);
+
+   seq_printf(seqf, "mac %02x:%02x:%02x:%02x:%02x:%02x ",
+                  port->paddr[0], port->paddr[1], port->paddr[2],
+                  port->paddr[3], port->paddr[4], port->paddr[5]);
+
+   seq_printf(seqf, "ladrf %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x ",
+                  port->ladrf[0], port->ladrf[1], port->ladrf[2],
+                  port->ladrf[3], port->ladrf[4], port->ladrf[5],
+                  port->ladrf[6], port->ladrf[7]);
+
+   seq_printf(seqf, "flags IFF_RUNNING");
+
+   if (port->flags & IFF_UP) {
+      seq_printf(seqf, ",IFF_UP");
+   }
+
+   if (port->flags & IFF_BROADCAST) {
+      seq_printf(seqf, ",IFF_BROADCAST");
+   }
+
+   if (port->flags & IFF_DEBUG) {
+      seq_printf(seqf, ",IFF_DEBUG");
+   }
+
+   if (port->flags & IFF_PROMISC) {
+      seq_printf(seqf, ",IFF_PROMISC");
+   }
+
+   if (port->flags & IFF_MULTICAST) {
+      seq_printf(seqf, ",IFF_MULTICAST");
+   }
+
+   if (port->flags & IFF_ALLMULTI) {
+      seq_printf(seqf, ",IFF_ALLMULTI");
+   }
+
+   seq_printf(seqf, " ");
+}
+#endif
 
 
 /*
diff --git a/vmnet-only/hub.c b/vmnet-only/hub.c
index 47f04ac..1e3d4f6 100644
--- a/vmnet-only/hub.c
+++ b/vmnet-only/hub.c
@@ -25,6 +25,9 @@
 #include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/poll.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10)
+#include <linux/seq_file.h>
+#endif
 
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -71,8 +74,10 @@ static void VNetHubReceive(VNetJack *this, struct sk_buff *skb);
 static Bool VNetHubCycleDetect(VNetJack *this, int generation);
 static void VNetHubPortsChanged(VNetJack *this);
 static int  VNetHubIsBridged(VNetJack *this);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
 static int  VNetHubProcRead(char *page, char **start, off_t off,
                             int count, int *eof, void *data);
+#endif
 
 static VNetHub *vnetHub;
 static DEFINE_SPINLOCK(vnetHubLock);
@@ -238,6 +243,55 @@ VNetHub_AllocPvn(uint8 id[]) // IN: the PVN ID to alloc on
    return VNetHubAlloc(TRUE, -1, id);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10)
+/*
+ *----------------------------------------------------------------------
+ *
+ * VNetHubProcShow --
+ *
+ *      Callback for read operation on hub entry in vnets proc fs.
+ *
+ * Results:
+ *      Length of read operation.
+ *
+ * Side effects:
+ *      None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+int
+VNetHubProcShow(struct seq_file  *seqf,   // IN/OUT: buffer to write into
+                void    *data)   // IN: client data - not used
+{
+   VNetJack *jack = (VNetJack*)data;
+   VNetHub *hub;
+
+   if (!jack || !jack->private) {
+      return 0;
+   }
+   hub = (VNetHub*)jack->private;
+
+   VNetPrintJack(jack, seqf);
+
+   seq_printf(seqf, "tx %u ", hub->stats[jack->index].tx);
+   seq_printf(seqf, "\n");
+   return 0;
+}
+
+static int proc_hub_open(struct inode *inode, struct file *file)
+{
+       return single_open(file, VNetHubProcShow, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_hub_fops = {
+       .open           = proc_hub_open,
+       .read           = seq_read,
+       .llseek         = seq_lseek,
+       .release        = seq_release,
+};
+#endif
+
 /*
  *----------------------------------------------------------------------
  *
@@ -354,7 +408,11 @@ VNetHubAlloc(Bool allocPvn, // IN: TRUE for PVN, FALSE for vnet
           * Make proc entry for this jack.
           */
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
          retval = VNetProc_MakeEntry(jack->name, S_IFREG, &jack->procEntry);
+#else
+         retval = VNetProc_MakeEntryOps(jack->name, S_IFREG, &jack->procEntry, &proc_hub_fops, jack);
+#endif
          if (retval) {
             if (retval == -ENXIO) {
                jack->procEntry = NULL;
@@ -362,9 +420,11 @@ VNetHubAlloc(Bool allocPvn, // IN: TRUE for PVN, FALSE for vnet
 	       hub->used[i] = FALSE;
                return NULL;
             }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
          } else {
             jack->procEntry->read_proc = VNetHubProcRead;
             jack->procEntry->data = jack;
+#endif
          }
 
          /*
@@ -686,46 +746,3 @@ VNetHubIsBridged(VNetJack *this)
 }
 
 
-/*
- *----------------------------------------------------------------------
- *
- * VNetHubProcRead --
- *
- *      Callback for read operation on hub entry in vnets proc fs.
- *
- * Results:
- *      Length of read operation.
- *
- * Side effects:
- *      None.
- *
- *----------------------------------------------------------------------
- */
-
-int
-VNetHubProcRead(char    *page,   // IN/OUT: buffer to write into
-                char   **start,  // OUT: 0 if file < 4k, else offset into page
-                off_t    off,    // IN: offset of read into the file
-                int      count,  // IN: maximum number of bytes to read
-                int     *eof,    // OUT: TRUE if there is nothing more to read
-                void    *data)   // IN: client data - not used
-{
-   VNetJack *jack = (VNetJack*)data;
-   VNetHub *hub;
-   int len = 0;
-
-   if (!jack || !jack->private) {
-      return len;
-   }
-   hub = (VNetHub*)jack->private;
-
-   len += VNetPrintJack(jack, page+len);
-
-   len += sprintf(page+len, "tx %u ", hub->stats[jack->index].tx);
-
-   len += sprintf(page+len, "\n");
-
-   *start = 0;
-   *eof   = 1;
-   return len;
-}
diff --git a/vmnet-only/netif.c b/vmnet-only/netif.c
index 1d269d6..01e9dae 100644
--- a/vmnet-only/netif.c
+++ b/vmnet-only/netif.c
@@ -62,8 +62,10 @@ static int  VNetNetifStartXmit(struct sk_buff *skb, struct net_device *dev);
 static struct net_device_stats *VNetNetifGetStats(struct net_device *dev);
 static int  VNetNetifSetMAC(struct net_device *dev, void *addr);
 static void VNetNetifSetMulticast(struct net_device *dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
 static int  VNetNetIfProcRead(char *page, char **start, off_t off,
                               int count, int *eof, void *data);
+#endif
 
 /*
  *----------------------------------------------------------------------
@@ -116,6 +118,55 @@ VNetNetIfSetup(struct net_device *dev)  // IN:
 
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10)
+/*
+ *----------------------------------------------------------------------
+ *
+ * VNetNetIfProcShow --
+ *
+ *      Callback for read operation on this netif entry in vnets proc fs.
+ *
+ * Results: 
+ *      Length of read operation.
+ *
+ * Side effects:
+ *      None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+int
+VNetNetIfProcShow(struct seq_file *seqf, // IN/OUT: buffer to write into
+                  void   *data)  // IN: client data
+{
+   VNetNetIF *netIf = data; 
+   
+   if (!netIf) {
+      return 0;
+   }
+   
+   VNetPrintPort(&netIf->port, seqf);
+
+   seq_printf(seqf, "dev %s ", netIf->dev->name);
+   
+   seq_printf(seqf, "\n");
+
+   return 0;
+}
+
+static int proc_netif_open(struct inode *inode, struct file *file)
+{
+       return single_open(file, VNetNetIfProcShow, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_netif_fops = {
+       .open           = proc_netif_open,
+       .read           = seq_read,
+       .llseek         = seq_lseek,
+       .release        = seq_release,
+};
+#endif
+
 
 /*
  *----------------------------------------------------------------------
@@ -180,16 +231,23 @@ VNetNetIf_Create(char *devName,  // IN:
     * Make proc entry for this jack.
     */
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
    retval = VNetProc_MakeEntry(netIf->port.jack.name, S_IFREG,
                                &netIf->port.jack.procEntry);
+#else
+   retval = VNetProc_MakeEntryOps(netIf->port.jack.name, S_IFREG,
+                               &netIf->port.jack.procEntry, &proc_netif_fops, netIf);
+#endif
    if (retval) {
       netIf->port.jack.procEntry = NULL;
       if (retval != -ENXIO) {
          goto outFreeDev;
       }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
    } else {
       netIf->port.jack.procEntry->read_proc = VNetNetIfProcRead;
       netIf->port.jack.procEntry->data = netIf;
+#endif
    }
 
    /*
@@ -554,6 +612,7 @@ VNetNetifGetStats(struct net_device *dev) // IN:
 }
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
 /*
  *----------------------------------------------------------------------
  *
@@ -595,3 +654,4 @@ VNetNetIfProcRead(char   *page,  // IN/OUT: buffer to write into
    *eof   = 1;
    return len;
 }
+#endif
diff --git a/vmnet-only/procfs.c b/vmnet-only/procfs.c
index ca42ee2..3fccd9f 100644
--- a/vmnet-only/procfs.c
+++ b/vmnet-only/procfs.c
@@ -45,9 +45,11 @@
 
 #if defined(CONFIG_PROC_FS)
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
 static int VNetProcMakeEntryInt(VNetProcEntry *parent, char *name, int mode,
                                 VNetProcEntry **ret);
 static void VNetProcRemoveEntryInt(VNetProcEntry *node, VNetProcEntry *parent);
+#endif
 
 static VNetProcEntry *base = NULL;
 
@@ -71,7 +73,16 @@ static VNetProcEntry *base = NULL;
 int
 VNetProc_Init(void)
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
    return VNetProcMakeEntryInt(NULL, "vmnet", S_IFDIR, &base);
+#else
+	base = proc_mkdir("vmnet", NULL);
+	if(IS_ERR(base)) {
+		base = NULL;
+		return PTR_ERR(base);
+	}
+	return 0;
+#endif
 }
 
 
@@ -94,10 +105,15 @@ VNetProc_Init(void)
 void
 VNetProc_Cleanup(void)
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
    VNetProcRemoveEntryInt(base, NULL);
+#else
+   proc_remove(base);
    base = NULL;
+#endif
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
 /*
  *----------------------------------------------------------------------
  *
@@ -182,6 +198,42 @@ VNetProc_MakeEntry(char            *name,  // IN:
 }
 
 
+#else
+/*
+ *----------------------------------------------------------------------
+ *
+ * VNetProc_MakeEntryOps --
+ *
+ *      Make an entry in the vnets proc file system.
+ *
+ * Results: 
+ *      errno. If errno is 0 and ret is non NULL then ret is filled
+ *      in with the resulting proc entry.
+ *      
+ * Side effects:
+ *      None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+int
+VNetProc_MakeEntryOps(char            *name,  // IN:
+		     int              mode,  // IN:
+		     VNetProcEntry  **ret,
+		     const struct file_operations *fops,
+		     void *data
+		     )   // OUT:
+{
+   VNetProcEntry *ent;
+   ent = proc_create_data(name, mode, base, fops, data);
+   *ret = ent;
+   if (!ent)
+      return -ENOMEM;
+   return 0;
+}
+#endif
+
+
 /*
  *----------------------------------------------------------------------
  *
@@ -201,7 +253,12 @@ VNetProc_MakeEntry(char            *name,  // IN:
 void
 VNetProc_RemoveEntry(VNetProcEntry *node)
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
    VNetProcRemoveEntryInt(node, base);
+#else
+	if(node)
+		proc_remove(node);
+#endif
 }
 
 
@@ -253,6 +310,7 @@ VNetProc_Cleanup(void)
 }
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
 /*
  *----------------------------------------------------------------------
  *
@@ -277,6 +335,7 @@ VNetProc_MakeEntry(char            *name,
 {
    return -ENXIO;
 }
+#endif
 
 
 /*
diff --git a/vmnet-only/userif.c b/vmnet-only/userif.c
index 293d6db..7d1c814 100644
--- a/vmnet-only/userif.c
+++ b/vmnet-only/userif.c
@@ -386,6 +386,7 @@ VNetUserIfReceive(VNetJack       *this, // IN
 }
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
 /*
  *----------------------------------------------------------------------
  *
@@ -440,6 +441,65 @@ VNetUserIfProcRead(char    *page,  // IN/OUT: buffer to write into
    *eof   = 1;
    return len;
 }
+#else
+/*
+ *----------------------------------------------------------------------
+ *
+ * VNetUserIfProcShow --
+ *
+ *      Callback for read operation on this userif entry in vnets proc fs.
+ *
+ * Results: 
+ *      Length of read operation.
+ *
+ * Side effects:
+ *      None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+VNetUserIfProcShow(struct seq_file    *seqf,  // IN/OUT: buffer to write into
+                   void    *data)  // IN: client data - not used
+{
+   VNetUserIF *userIf = (VNetUserIF*)data; 
+   
+   if (!userIf) {
+      return 0;
+   }
+   
+   VNetPrintPort(&userIf->port, seqf);
+   
+   seq_printf(seqf, "read %u written %u queued %u ",
+                  userIf->stats.read,
+                  userIf->stats.written,
+                  userIf->stats.queued);
+   
+   seq_printf(seqf, 
+		  "dropped.down %u dropped.mismatch %u "
+		  "dropped.overflow %u dropped.largePacket %u",
+                  userIf->stats.droppedDown,
+                  userIf->stats.droppedMismatch,
+                  userIf->stats.droppedOverflow,
+		  userIf->stats.droppedLargePacket);
+
+   seq_printf(seqf, "\n");
+   
+   return 0;
+}
+
+static int proc_userif_open(struct inode *inode, struct file *file)
+{
+       return single_open(file, VNetUserIfProcShow, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_userif_fops = {
+       .open           = proc_userif_open,
+       .read           = seq_read,
+       .llseek         = seq_lseek,
+       .release        = seq_release,
+};
+#endif
 
 
 /*
@@ -1036,8 +1096,13 @@ VNetUserIf_Create(VNetPort **ret) // OUT
     * Make proc entry for this jack.
     */
    
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
    retval = VNetProc_MakeEntry(userIf->port.jack.name, S_IFREG,
-                               &userIf->port.jack.procEntry);
+                               &userIf->port.jack.procEntry)
+#else
+   retval = VNetProc_MakeEntryOps(userIf->port.jack.name, S_IFREG,
+                               &userIf->port.jack.procEntry, &proc_userif_fops, userIf);
+#endif
    if (retval) {
       if (retval == -ENXIO) {
          userIf->port.jack.procEntry = NULL;
@@ -1045,9 +1110,11 @@ VNetUserIf_Create(VNetPort **ret) // OUT
          kfree(userIf);
          return retval;
       }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
    } else {
       userIf->port.jack.procEntry->read_proc = VNetUserIfProcRead;
       userIf->port.jack.procEntry->data = userIf;
+#endif
    }
 
    /*
diff --git a/vmnet-only/vnetInt.h b/vmnet-only/vnetInt.h
index c615395..a4a1f16 100644
--- a/vmnet-only/vnetInt.h
+++ b/vmnet-only/vnetInt.h
@@ -171,12 +171,23 @@ VNetJack *VNetDisconnect(VNetJack *jack);
 
 void VNetSend(const VNetJack *jack, struct sk_buff *skb);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
 int VNetProc_MakeEntry(char *name, int mode,
                        VNetProcEntry **ret);
+#else
+int VNetProc_MakeEntryOps(char *name, int mode,
+                       VNetProcEntry **ret,
+		       const struct file_operations *fops,
+		       void *data);
+#endif
 
 void VNetProc_RemoveEntry(VNetProcEntry *node);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
 int VNetPrintJack(const VNetJack *jack, char *buf);
+#else
+void VNetPrintJack(const VNetJack *jack, struct seq_file *seqf);
+#endif
 
 int VNet_MakeMACAddress(VNetPort *port);
 
@@ -196,7 +207,11 @@ Bool VNetPacketMatch(const uint8 *destAddr, const uint8 *ifAddr,
 
 Bool VNetCycleDetectIf(const char *name, int generation);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
 int VNetPrintPort(const VNetPort *port, char *buf);
+#else
+void VNetPrintPort(const VNetPort *port, struct seq_file *seqf);
+#endif
 
 int VNetSnprintf(char *str, size_t size, const char *format, ...);
 
-- 
2.0.0


From d919833f151ca41f084afcdb017e9b111377f19e Mon Sep 17 00:00:00 2001
From: Adrian Bacircea <adrian.bacircea@gmail.com>
Date: Sat, 16 Nov 2013 12:59:54 +0200
Subject: [PATCH 02/10] Fix wrong use of KERNEL_VERSION macro

---
 vmblock-only/linux/control.c |   4 +-
 vmblock-only/linux/file.c    |  10 +--
 vmblock-only/linux/inode.c   |   6 +-
 vmnet-only/bridge.c          |  10 +--
 vmnet-only/driver.c          |   8 +--
 vmnet-only/hub.c             |  10 +--
 vmnet-only/netif.c           |  82 +++++++++++------------
 vmnet-only/procfs.c          |  42 ++++++------
 vmnet-only/userif.c          | 150 +++++++++++++++++++++----------------------
 vmnet-only/vnetInt.h         |  32 ++++-----
 10 files changed, 177 insertions(+), 177 deletions(-)

diff --git a/vmblock-only/linux/control.c b/vmblock-only/linux/control.c
index 579fb10..a245793 100644
--- a/vmblock-only/linux/control.c
+++ b/vmblock-only/linux/control.c
@@ -208,7 +208,7 @@ SetupProcDevice(void)
    VMBlockSetProcEntryOwner(controlProcMountpoint);
 
    /* Create /proc/fs/vmblock/dev */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
    controlProcEntry = proc_create(VMBLOCK_CONTROL_DEVNAME,
                                   VMBLOCK_CONTROL_MODE,
                                   controlProcDirEntry,
@@ -225,7 +225,7 @@ SetupProcDevice(void)
       return -EINVAL;
    }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
    controlProcEntry->proc_fops = &ControlFileOps;
 #endif
    return 0;
diff --git a/vmblock-only/linux/file.c b/vmblock-only/linux/file.c
index 2e42034..21fa62f 100644
--- a/vmblock-only/linux/file.c
+++ b/vmblock-only/linux/file.c
@@ -38,7 +38,7 @@ typedef u64 inode_num_t;
 typedef ino_t inode_num_t;
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0)
 /* Specifically for our filldir_t callback */
 typedef struct FilldirInfo {
    filldir_t filldir;
@@ -167,7 +167,7 @@ FileOpOpen(struct inode *inode,  // IN
 
 static int
 FileOpReaddir(struct file *file,  // IN
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0)
               void *dirent,       // IN
               filldir_t filldir)  // IN
 #else
@@ -175,7 +175,7 @@ FileOpReaddir(struct file *file,  // IN
 #endif
 {
    int ret;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0)
    FilldirInfo info;
 #endif
    struct file *actualFile;
@@ -191,7 +191,7 @@ FileOpReaddir(struct file *file,  // IN
       return -EINVAL;
    }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0)
    info.filldir = filldir;
    info.dirent = dirent;
 
@@ -252,7 +252,7 @@ FileOpRelease(struct inode *inode, // IN
 
 
 struct file_operations RootFileOps = {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0)
    .readdir = FileOpReaddir,
 #else
    .iterate = FileOpReaddir,
diff --git a/vmblock-only/linux/inode.c b/vmblock-only/linux/inode.c
index cf2ed00..b56fc85 100644
--- a/vmblock-only/linux/inode.c
+++ b/vmblock-only/linux/inode.c
@@ -37,7 +37,7 @@
 /* Inode operations */
 static struct dentry *InodeOpLookup(struct inode *dir,
                                     struct dentry *dentry,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,12)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0)
                                     struct nameidata *nd);
 #else
                                     unsigned int flags);
@@ -80,7 +80,7 @@ static struct inode_operations LinkInodeOps = {
 static struct dentry *
 InodeOpLookup(struct inode *dir,      // IN: parent directory's inode
               struct dentry *dentry,  // IN: dentry to lookup
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,12)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0)
               struct nameidata *nd)   // IN: lookup intent and information
 #else
               unsigned int flags)     // IN: lookup intent and information
@@ -230,7 +230,7 @@ InodeOpFollowlink(struct dentry *dentry,  // IN : dentry of symlink
       goto out;
    }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,12)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0)
    ret = vfs_follow_link(nd, iinfo->name);
 #else
    nd_set_link(nd, iinfo->name);
diff --git a/vmnet-only/bridge.c b/vmnet-only/bridge.c
index 62d47c0..b94f14f 100644
--- a/vmnet-only/bridge.c
+++ b/vmnet-only/bridge.c
@@ -105,7 +105,7 @@ static Bool VNetBridgeCycleDetect(VNetJack *this, int generation);
 static Bool VNetBridgeIsDeviceWireless(struct net_device *dev);
 static void VNetBridgePortsChanged(VNetJack *this);
 static int  VNetBridgeIsBridged(VNetJack *this);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 static int  VNetBridgeProcRead(char *page, char **start, off_t off,
                                int count, int *eof, void *data);
 #endif
@@ -223,7 +223,7 @@ VNetBridgeDevCompatible(VNetBridge *bridge,      // IN: Bridge
    return strcmp(net->name, bridge->name) == 0;
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
 /*
  *----------------------------------------------------------------------
  *
@@ -369,7 +369,7 @@ VNetBridge_Create(const char *devName, // IN:  name of device (e.g., "eth0")
     * Make proc entry for this jack.
     */
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
    retval = VNetProc_MakeEntry(bridge->port.jack.name, S_IFREG,
                                &bridge->port.jack.procEntry);
 #else
@@ -382,7 +382,7 @@ VNetBridge_Create(const char *devName, // IN:  name of device (e.g., "eth0")
       } else {
          goto out;
       }
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
    } else {
       bridge->port.jack.procEntry->read_proc = VNetBridgeProcRead;
       bridge->port.jack.procEntry->data = bridge;
@@ -1776,7 +1776,7 @@ VNetBridgeReceiveFromDev(struct sk_buff *skb,         // IN: packet to receive
    return 0;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 /*
  *----------------------------------------------------------------------
  *
diff --git a/vmnet-only/driver.c b/vmnet-only/driver.c
index 157eb05..4dc5533 100644
--- a/vmnet-only/driver.c
+++ b/vmnet-only/driver.c
@@ -1399,12 +1399,12 @@ VNetMulticastFilter(const uint8 *destAddr,        // IN: multicast MAC
       }
       /*
        * Do not need to further compute and check ladrf if no match
-       * in exact multicast filter, since only one of them is 
+       * in exact multicast filter, since only one of them is
        * used at a time.
        */
       return FALSE;
    }
-   
+
 
    crc = 0xffffffff;                  /* init CRC for each address */
    for (byte = 0; byte < ETH_ALEN; byte++) { /* for each address byte */
@@ -1785,7 +1785,7 @@ VNetSetMACUnique(VNetPort *port,            // IN:
  *----------------------------------------------------------------------
  */
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int
 VNetPrintJack(const VNetJack *jack, // IN: jack
               char           *buf)  // OUT: info about jack
@@ -1834,7 +1834,7 @@ VNetPrintJack(const VNetJack *jack, // IN: jack
  *----------------------------------------------------------------------
  */
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int
 VNetPrintPort(const VNetPort *port, // IN: port
               char           *buf)  // OUT: info about port
diff --git a/vmnet-only/hub.c b/vmnet-only/hub.c
index 1e3d4f6..353caaa 100644
--- a/vmnet-only/hub.c
+++ b/vmnet-only/hub.c
@@ -25,7 +25,7 @@
 #include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/poll.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
 #include <linux/seq_file.h>
 #endif
 
@@ -74,7 +74,7 @@ static void VNetHubReceive(VNetJack *this, struct sk_buff *skb);
 static Bool VNetHubCycleDetect(VNetJack *this, int generation);
 static void VNetHubPortsChanged(VNetJack *this);
 static int  VNetHubIsBridged(VNetJack *this);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 static int  VNetHubProcRead(char *page, char **start, off_t off,
                             int count, int *eof, void *data);
 #endif
@@ -243,7 +243,7 @@ VNetHub_AllocPvn(uint8 id[]) // IN: the PVN ID to alloc on
    return VNetHubAlloc(TRUE, -1, id);
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
 /*
  *----------------------------------------------------------------------
  *
@@ -408,7 +408,7 @@ VNetHubAlloc(Bool allocPvn, // IN: TRUE for PVN, FALSE for vnet
           * Make proc entry for this jack.
           */
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
          retval = VNetProc_MakeEntry(jack->name, S_IFREG, &jack->procEntry);
 #else
          retval = VNetProc_MakeEntryOps(jack->name, S_IFREG, &jack->procEntry, &proc_hub_fops, jack);
@@ -420,7 +420,7 @@ VNetHubAlloc(Bool allocPvn, // IN: TRUE for PVN, FALSE for vnet
 	       hub->used[i] = FALSE;
                return NULL;
             }
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
          } else {
             jack->procEntry->read_proc = VNetHubProcRead;
             jack->procEntry->data = jack;
diff --git a/vmnet-only/netif.c b/vmnet-only/netif.c
index 01e9dae..6fe854b 100644
--- a/vmnet-only/netif.c
+++ b/vmnet-only/netif.c
@@ -62,7 +62,7 @@ static int  VNetNetifStartXmit(struct sk_buff *skb, struct net_device *dev);
 static struct net_device_stats *VNetNetifGetStats(struct net_device *dev);
 static int  VNetNetifSetMAC(struct net_device *dev, void *addr);
 static void VNetNetifSetMulticast(struct net_device *dev);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 static int  VNetNetIfProcRead(char *page, char **start, off_t off,
                               int count, int *eof, void *data);
 #endif
@@ -73,8 +73,8 @@ static int  VNetNetIfProcRead(char *page, char **start, off_t off,
  * VNetNetIfSetup --
  *
  *      Sets initial netdevice state.
- * 
- * Results: 
+ *
+ * Results:
  *      None.
  *
  * Side effects:
@@ -104,7 +104,7 @@ VNetNetIfSetup(struct net_device *dev)  // IN:
 #endif
 
    ether_setup(dev); // turns on IFF_BROADCAST, IFF_MULTICAST
-#if COMPAT_LINUX_VERSION_CHECK_LT(3, 1, 0) && !defined(HAVE_NET_DEVICE_OPS) 
+#if COMPAT_LINUX_VERSION_CHECK_LT(3, 1, 0) && !defined(HAVE_NET_DEVICE_OPS)
    dev->init = VNetNetifProbe;
    dev->open = VNetNetifOpen;
    dev->hard_start_xmit = VNetNetifStartXmit;
@@ -118,7 +118,7 @@ VNetNetIfSetup(struct net_device *dev)  // IN:
 
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
 /*
  *----------------------------------------------------------------------
  *
@@ -126,7 +126,7 @@ VNetNetIfSetup(struct net_device *dev)  // IN:
  *
  *      Callback for read operation on this netif entry in vnets proc fs.
  *
- * Results: 
+ * Results:
  *      Length of read operation.
  *
  * Side effects:
@@ -139,16 +139,16 @@ int
 VNetNetIfProcShow(struct seq_file *seqf, // IN/OUT: buffer to write into
                   void   *data)  // IN: client data
 {
-   VNetNetIF *netIf = data; 
-   
+   VNetNetIF *netIf = data;
+
    if (!netIf) {
       return 0;
    }
-   
+
    VNetPrintPort(&netIf->port, seqf);
 
    seq_printf(seqf, "dev %s ", netIf->dev->name);
-   
+
    seq_printf(seqf, "\n");
 
    return 0;
@@ -175,8 +175,8 @@ static const struct file_operations proc_netif_fops = {
  *
  *      Create a net level port to the wonderful world of virtual
  *      networking.
- * 
- * Results: 
+ *
+ * Results:
  *      Errno. Also returns an allocated port to connect to,
  *      NULL on error.
  *
@@ -189,7 +189,7 @@ static const struct file_operations proc_netif_fops = {
 int
 VNetNetIf_Create(char *devName,  // IN:
                  VNetPort **ret, // OUT:
-                 int hubNum)     // IN: 
+                 int hubNum)     // IN:
 {
    VNetNetIF *netIf;
    struct net_device *dev;
@@ -231,7 +231,7 @@ VNetNetIf_Create(char *devName,  // IN:
     * Make proc entry for this jack.
     */
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
    retval = VNetProc_MakeEntry(netIf->port.jack.name, S_IFREG,
                                &netIf->port.jack.procEntry);
 #else
@@ -243,7 +243,7 @@ VNetNetIf_Create(char *devName,  // IN:
       if (retval != -ENXIO) {
          goto outFreeDev;
       }
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
    } else {
       netIf->port.jack.procEntry->read_proc = VNetNetIfProcRead;
       netIf->port.jack.procEntry->data = netIf;
@@ -336,7 +336,7 @@ VNetNetIfFree(VNetJack *this) // IN: jack
  *
  *      This jack is receiving a packet. Take appropriate action.
  *
- * Results: 
+ * Results:
  *      None.
  *
  * Side effects:
@@ -347,11 +347,11 @@ VNetNetIfFree(VNetJack *this) // IN: jack
 
 void
 VNetNetIfReceive(VNetJack        *this, // IN: jack
-		 struct sk_buff  *skb)  // IN: packet 
+		 struct sk_buff  *skb)  // IN: packet
 {
    VNetNetIF *netIf = this->private;
    uint8 *dest = SKB_2_DESTMAC(skb);
- 
+
    if (!NETDEV_UP_AND_RUNNING(netIf->dev)) {
       goto drop_packet;
    }
@@ -364,7 +364,7 @@ VNetNetIfReceive(VNetJack        *this, // IN: jack
                         netIf->dev->flags)) {
       goto drop_packet;
    }
-   
+
    /* send to the host interface */
    skb->dev = netIf->dev;
    skb->protocol = eth_type_trans(skb, netIf->dev);
@@ -372,7 +372,7 @@ VNetNetIfReceive(VNetJack        *this, // IN: jack
    netIf->stats.rx_packets++;
 
    return;
-   
+
  drop_packet:
    dev_kfree_skb(skb);
 }
@@ -384,8 +384,8 @@ VNetNetIfReceive(VNetJack        *this, // IN: jack
  * VNetNetIfCycleDetect --
  *
  *      Cycle detection algorithm.
- * 
- * Results: 
+ *
+ * Results:
  *      TRUE if a cycle was detected, FALSE otherwise.
  *
  * Side effects:
@@ -396,7 +396,7 @@ VNetNetIfReceive(VNetJack        *this, // IN: jack
 
 Bool
 VNetNetIfCycleDetect(VNetJack *this,       // IN: jack
-                     int       generation) // IN: 
+                     int       generation) // IN:
 {
    VNetNetIF *netIf = this->private;
 
@@ -409,9 +409,9 @@ VNetNetIfCycleDetect(VNetJack *this,       // IN: jack
  *
  * VNetNetifOpen --
  *
- *      The virtual network's open dev operation. 
+ *      The virtual network's open dev operation.
  *
- * Results: 
+ * Results:
  *      errno.
  *
  * Side effects:
@@ -446,7 +446,7 @@ VNetNetifOpen(struct net_device *dev) // IN:
  *
  *      ???
  *
- * Results: 
+ * Results:
  *      0.
  *
  * Side effects:
@@ -467,9 +467,9 @@ VNetNetifProbe(struct net_device *dev) // IN: unused
  *
  * VNetNetifClose --
  *
- *      The virtual network's close dev operation. 
+ *      The virtual network's close dev operation.
  *
- * Results: 
+ * Results:
  *      errno.
  *
  * Side effects:
@@ -492,9 +492,9 @@ VNetNetifClose(struct net_device *dev) // IN:
  *
  * VNetNetifStartXmit --
  *
- *      The virtual network's start xmit dev operation. 
+ *      The virtual network's start xmit dev operation.
  *
- * Results: 
+ * Results:
  *      ???, 0.
  *
  * Side effects:
@@ -535,7 +535,7 @@ VNetNetifStartXmit(struct sk_buff    *skb, // IN:
  *
  *      Sets MAC address (i.e. via ifconfig) of netif device.
  *
- * Results: 
+ * Results:
  *      Errno.
  *
  * Side effects:
@@ -570,9 +570,9 @@ VNetNetifSetMAC(struct net_device *dev, // IN:
  *      dev->mc_count.
  *
  *      Since host-only network ifaces can't be bridged, it's debatable
- *      whether this is at all useful, but at least now you can turn it 
+ *      whether this is at all useful, but at least now you can turn it
  *      on from ifconfig without getting an ioctl error.
- * Results: 
+ * Results:
  *      Void.
  *
  * Side effects:
@@ -592,9 +592,9 @@ VNetNetifSetMulticast(struct net_device *dev) // IN: unused
  *
  * VNetNetifGetStats --
  *
- *      The virtual network's get stats dev operation. 
+ *      The virtual network's get stats dev operation.
  *
- * Results: 
+ * Results:
  *      A struct full of stats.
  *
  * Side effects:
@@ -612,7 +612,7 @@ VNetNetifGetStats(struct net_device *dev) // IN:
 }
 
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 /*
  *----------------------------------------------------------------------
  *
@@ -620,7 +620,7 @@ VNetNetifGetStats(struct net_device *dev) // IN:
  *
  *      Callback for read operation on this netif entry in vnets proc fs.
  *
- * Results: 
+ * Results:
  *      Length of read operation.
  *
  * Side effects:
@@ -637,17 +637,17 @@ VNetNetIfProcRead(char   *page,  // IN/OUT: buffer to write into
                   int    *eof,   // OUT: TRUE if there is nothing more to read
                   void   *data)  // IN: client data
 {
-   VNetNetIF *netIf = data; 
+   VNetNetIF *netIf = data;
    int len = 0;
-   
+
    if (!netIf) {
       return len;
    }
-   
+
    len += VNetPrintPort(&netIf->port, page+len);
 
    len += sprintf(page+len, "dev %s ", netIf->dev->name);
-   
+
    len += sprintf(page+len, "\n");
 
    *start = 0;
diff --git a/vmnet-only/procfs.c b/vmnet-only/procfs.c
index 3fccd9f..e812d64 100644
--- a/vmnet-only/procfs.c
+++ b/vmnet-only/procfs.c
@@ -45,7 +45,7 @@
 
 #if defined(CONFIG_PROC_FS)
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 static int VNetProcMakeEntryInt(VNetProcEntry *parent, char *name, int mode,
                                 VNetProcEntry **ret);
 static void VNetProcRemoveEntryInt(VNetProcEntry *node, VNetProcEntry *parent);
@@ -61,7 +61,7 @@ static VNetProcEntry *base = NULL;
  *
  *      Initialize the vnets procfs entries.
  *
- * Results: 
+ * Results:
  *      errno.
  *
  * Side effects:
@@ -73,7 +73,7 @@ static VNetProcEntry *base = NULL;
 int
 VNetProc_Init(void)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
    return VNetProcMakeEntryInt(NULL, "vmnet", S_IFDIR, &base);
 #else
 	base = proc_mkdir("vmnet", NULL);
@@ -93,7 +93,7 @@ VNetProc_Init(void)
  *
  *      Cleanup the vnets proc filesystem entries.
  *
- * Results: 
+ * Results:
  *      None.
  *
  * Side effects:
@@ -105,7 +105,7 @@ VNetProc_Init(void)
 void
 VNetProc_Cleanup(void)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
    VNetProcRemoveEntryInt(base, NULL);
 #else
    proc_remove(base);
@@ -113,7 +113,7 @@ VNetProc_Cleanup(void)
 #endif
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 /*
  *----------------------------------------------------------------------
  *
@@ -121,10 +121,10 @@ VNetProc_Cleanup(void)
  *
  *      Make an entry in the vnets proc file system.
  *
- * Results: 
+ * Results:
  *      errno. If errno is 0 and ret is non NULL then ret is filled
  *      in with the resulting proc entry.
- *      
+ *
  * Side effects:
  *      None.
  *
@@ -153,7 +153,7 @@ VNetProcMakeEntryInt(VNetProcEntry  *parent, // IN:
  *
  *      Remove a previously installed proc entry.
  *
- * Results: 
+ * Results:
  *      None.
  *
  * Side effects:
@@ -179,10 +179,10 @@ VNetProcRemoveEntryInt(VNetProcEntry *node,
  *
  *      Make an entry in the vnets proc file system.
  *
- * Results: 
+ * Results:
  *      errno. If errno is 0 and ret is non NULL then ret is filled
  *      in with the resulting proc entry.
- *      
+ *
  * Side effects:
  *      None.
  *
@@ -206,10 +206,10 @@ VNetProc_MakeEntry(char            *name,  // IN:
  *
  *      Make an entry in the vnets proc file system.
  *
- * Results: 
+ * Results:
  *      errno. If errno is 0 and ret is non NULL then ret is filled
  *      in with the resulting proc entry.
- *      
+ *
  * Side effects:
  *      None.
  *
@@ -241,7 +241,7 @@ VNetProc_MakeEntryOps(char            *name,  // IN:
  *
  *      Remove a previously installed proc entry.
  *
- * Results: 
+ * Results:
  *      None.
  *
  * Side effects:
@@ -253,7 +253,7 @@ VNetProc_MakeEntryOps(char            *name,  // IN:
 void
 VNetProc_RemoveEntry(VNetProcEntry *node)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
    VNetProcRemoveEntryInt(node, base);
 #else
 	if(node)
@@ -272,7 +272,7 @@ VNetProc_RemoveEntry(VNetProcEntry *node)
  *
  *      Initialize the vnets procfs entries.
  *
- * Results: 
+ * Results:
  *      errno.
  *
  * Side effects:
@@ -295,7 +295,7 @@ VNetProc_Init(void)
  *
  *      Cleanup the vnets proc filesystem entries.
  *
- * Results: 
+ * Results:
  *      None.
  *
  * Side effects:
@@ -310,7 +310,7 @@ VNetProc_Cleanup(void)
 }
 
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 /*
  *----------------------------------------------------------------------
  *
@@ -318,10 +318,10 @@ VNetProc_Cleanup(void)
  *
  *      Make an entry in the vnets proc file system.
  *
- * Results: 
+ * Results:
  *      errno. If errno is 0 and ret is non NULL then ret is filled
  *      in with the resulting proc entry.
- *      
+ *
  * Side effects:
  *      None.
  *
@@ -345,7 +345,7 @@ VNetProc_MakeEntry(char            *name,
  *
  *      Remove a previously installed proc entry.
  *
- * Results: 
+ * Results:
  *      None.
  *
  * Side effects:
diff --git a/vmnet-only/userif.c b/vmnet-only/userif.c
index 7d1c814..15065f8 100644
--- a/vmnet-only/userif.c
+++ b/vmnet-only/userif.c
@@ -179,13 +179,13 @@ VNetUserIfMapUint32Ptr(VA uAddr,        // IN: pointer to user memory
  *
  *    Sets up notification by filling in pollPtr, actPtr, and recvClusterCount
  *    fields.
- * 
- * Results: 
+ *
+ * Results:
  *    0 on success
  *    < 0 on failure: the actual value determines the type of failure
  *
  * Side effects:
- *    Fields pollPtr, actPtr, recvClusterCount, pollPage, actPage, and 
+ *    Fields pollPtr, actPtr, recvClusterCount, pollPage, actPage, and
  *    recvClusterPage are filled in VNetUserIf structure.
  *
  *-----------------------------------------------------------------------------
@@ -214,7 +214,7 @@ VNetUserIfSetupNotify(VNetUserIF *userIf, // IN
       return retval;
    }
 
-   if ((retval = VNetUserIfMapUint32Ptr((VA)vn->recvClusterPtr, 
+   if ((retval = VNetUserIfMapUint32Ptr((VA)vn->recvClusterPtr,
                                         &userIf->recvClusterPage,
                                         &userIf->recvClusterCount)) < 0) {
       VNetUserIfUnsetupNotify(userIf);
@@ -232,8 +232,8 @@ VNetUserIfSetupNotify(VNetUserIF *userIf, // IN
  * VNetUserIfUnsetupNotify --
  *
  *      Destroys permanent mapping for notify structure provided by user.
- * 
- * Results: 
+ *
+ * Results:
  *      None.
  *
  * Side effects:
@@ -282,7 +282,7 @@ VNetUserIfUnsetupNotify(VNetUserIF *userIf) // IN
  *
  *      Free the user interface port.
  *
- * Results: 
+ * Results:
  *      None.
  *
  * Side effects:
@@ -304,7 +304,7 @@ VNetUserIfFree(VNetJack *this) // IN
       }
       dev_kfree_skb(skb);
    }
-   
+
    if (userIf->pollPtr) {
       VNetUserIfUnsetupNotify(userIf);
    }
@@ -328,7 +328,7 @@ VNetUserIfFree(VNetJack *this) // IN
  *
  *      This jack is receiving a packet. Take appropriate action.
  *
- * Results: 
+ * Results:
  *      None.
  *
  * Side effects:
@@ -343,12 +343,12 @@ VNetUserIfReceive(VNetJack       *this, // IN
 {
    VNetUserIF *userIf = (VNetUserIF*)this->private;
    uint8 *dest = SKB_2_DESTMAC(skb);
-   
+
    if (!UP_AND_RUNNING(userIf->port.flags)) {
       userIf->stats.droppedDown++;
       goto drop_packet;
    }
-   
+
    if (!VNetPacketMatch(dest,
                         userIf->port.paddr,
                         (const uint8 *)userIf->port.exactFilter,
@@ -358,12 +358,12 @@ VNetUserIfReceive(VNetJack       *this, // IN
       userIf->stats.droppedMismatch++;
       goto drop_packet;
    }
-   
+
    if (skb_queue_len(&userIf->packetQueue) >= vnet_max_qlen) {
       userIf->stats.droppedOverflow++;
       goto drop_packet;
    }
-   
+
    if (skb->len > ETHER_MAX_QUEUED_PACKET) {
       userIf->stats.droppedLargePacket++;
       goto drop_packet;
@@ -380,13 +380,13 @@ VNetUserIfReceive(VNetJack       *this, // IN
    }
    wake_up(&userIf->waitQueue);
    return;
-   
+
  drop_packet:
    dev_kfree_skb(skb);
 }
 
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 /*
  *----------------------------------------------------------------------
  *
@@ -394,7 +394,7 @@ VNetUserIfReceive(VNetJack       *this, // IN
  *
  *      Callback for read operation on this userif entry in vnets proc fs.
  *
- * Results: 
+ * Results:
  *      Length of read operation.
  *
  * Side effects:
@@ -413,21 +413,21 @@ VNetUserIfProcRead(char    *page,  // IN/OUT: buffer to write into
                                    //      read
                    void    *data)  // IN: client data - not used
 {
-   VNetUserIF *userIf = (VNetUserIF*)data; 
+   VNetUserIF *userIf = (VNetUserIF*)data;
    int len = 0;
-   
+
    if (!userIf) {
       return len;
    }
-   
+
    len += VNetPrintPort(&userIf->port, page+len);
-   
+
    len += sprintf(page+len, "read %u written %u queued %u ",
                   userIf->stats.read,
                   userIf->stats.written,
                   userIf->stats.queued);
-   
-   len += sprintf(page+len, 
+
+   len += sprintf(page+len,
 		  "dropped.down %u dropped.mismatch %u "
 		  "dropped.overflow %u dropped.largePacket %u",
                   userIf->stats.droppedDown,
@@ -436,7 +436,7 @@ VNetUserIfProcRead(char    *page,  // IN/OUT: buffer to write into
 		  userIf->stats.droppedLargePacket);
 
    len += sprintf(page+len, "\n");
-   
+
    *start = 0;
    *eof   = 1;
    return len;
@@ -449,7 +449,7 @@ VNetUserIfProcRead(char    *page,  // IN/OUT: buffer to write into
  *
  *      Callback for read operation on this userif entry in vnets proc fs.
  *
- * Results: 
+ * Results:
  *      Length of read operation.
  *
  * Side effects:
@@ -462,20 +462,20 @@ static int
 VNetUserIfProcShow(struct seq_file    *seqf,  // IN/OUT: buffer to write into
                    void    *data)  // IN: client data - not used
 {
-   VNetUserIF *userIf = (VNetUserIF*)data; 
-   
+   VNetUserIF *userIf = (VNetUserIF*)data;
+
    if (!userIf) {
       return 0;
    }
-   
+
    VNetPrintPort(&userIf->port, seqf);
-   
+
    seq_printf(seqf, "read %u written %u queued %u ",
                   userIf->stats.read,
                   userIf->stats.written,
                   userIf->stats.queued);
-   
-   seq_printf(seqf, 
+
+   seq_printf(seqf,
 		  "dropped.down %u dropped.mismatch %u "
 		  "dropped.overflow %u dropped.largePacket %u",
                   userIf->stats.droppedDown,
@@ -484,7 +484,7 @@ VNetUserIfProcShow(struct seq_file    *seqf,  // IN/OUT: buffer to write into
 		  userIf->stats.droppedLargePacket);
 
    seq_printf(seqf, "\n");
-   
+
    return 0;
 }
 
@@ -509,7 +509,7 @@ static const struct file_operations proc_userif_fops = {
  *
  *      Copy part of datagram to userspace.
  *
- * Results: 
+ * Results:
  *	zero    on success,
  *	-EFAULT if buffer is an invalid area
  *
@@ -539,12 +539,12 @@ VNetCopyDatagram(const struct sk_buff *skb,	// IN: skb to copy
  *
  *      Copy part of datagram to userspace doing checksum at same time.
  *
- *	Do not mark this function INLINE, it is recursive! With all gcc's 
+ *	Do not mark this function INLINE, it is recursive! With all gcc's
  *	released up to now (<= gcc-3.3.1) inlining this function just
  *	consumes 120 more bytes of code and goes completely mad on
  *	register allocation, storing almost everything in the memory.
  *
- * Results: 
+ * Results:
  *	folded checksum (non-negative value) on success,
  *	-EINVAL if offset is too big,
  *	-EFAULT if buffer is an invalid area
@@ -566,7 +566,7 @@ VNetCsumCopyDatagram(const struct sk_buff *skb,	// IN: skb to copy
    char *curr = buf;
    const skb_frag_t *frag;
 
-   /* 
+   /*
     * Something bad happened. We skip only up to skb->nh.raw, and skb->nh.raw
     * must be in the header, otherwise we are in the big troubles.
     */
@@ -623,7 +623,7 @@ VNetCsumCopyDatagram(const struct sk_buff *skb,	// IN: skb to copy
  *      Copy complete datagram to the user space. Fill correct checksum
  *	into the copied datagram if nobody did it yet.
  *
- * Results: 
+ * Results:
  *      On success byte count, on failure -EFAULT.
  *
  * Side effects:
@@ -652,7 +652,7 @@ VNetCopyDatagramToUser(const struct sk_buff *skb,	// IN
       size_t skl;
       int csum;
       u_int16_t csum16;
-     
+
       skl = compat_skb_csum_start(skb);
       if (VNetCopyDatagram(skb, buf, skl)) {
 	 return -EFAULT;
@@ -683,7 +683,7 @@ VNetCopyDatagramToUser(const struct sk_buff *skb,	// IN
  *      The virtual network's read file operation. Reads the next pending
  *      packet for this network connection.
  *
- * Results: 
+ * Results:
  *      On success the len of the packet received,
  *      else if no packet waiting and nonblocking 0,
  *      else -errno.
@@ -694,7 +694,7 @@ VNetCopyDatagramToUser(const struct sk_buff *skb,	// IN
  *----------------------------------------------------------------------
  */
 
-static int 
+static int
 VNetUserIfRead(VNetPort    *port, // IN
                struct file *filp, // IN
                char        *buf,  // OUT
@@ -754,7 +754,7 @@ VNetUserIfRead(VNetPort    *port, // IN
  *      The virtual network's write file operation. Send the raw packet
  *      to the network.
  *
- * Results: 
+ * Results:
  *      On success the count of bytes written else errno.
  *
  * Side effects:
@@ -763,7 +763,7 @@ VNetUserIfRead(VNetPort    *port, // IN
  *----------------------------------------------------------------------
  */
 
-static int 
+static int
 VNetUserIfWrite(VNetPort    *port, // IN
                 struct file *filp, // IN
                 const char  *buf,  // IN
@@ -775,8 +775,8 @@ VNetUserIfWrite(VNetPort    *port, // IN
    /*
     * Check size
     */
-   
-   if (count < sizeof (struct ethhdr) || 
+
+   if (count < sizeof (struct ethhdr) ||
        count > ETHER_MAX_QUEUED_PACKET) {
       return -EINVAL;
    }
@@ -793,25 +793,25 @@ VNetUserIfWrite(VNetPort    *port, // IN
    /*
     * Allocate an sk_buff.
     */
-   
+
    skb = dev_alloc_skb(count + 7);
    if (skb == NULL) {
       // XXX obey O_NONBLOCK?
       return -ENOBUFS;
    }
-   
+
    skb_reserve(skb, 2);
-   
+
    /*
     * Copy the data and send it.
     */
-   
+
    userIf->stats.written++;
    if (copy_from_user(skb_put(skb, count), buf, count)) {
       dev_kfree_skb(skb);
       return -EFAULT;
    }
-   
+
    VNetSend(&userIf->port.jack, skb);
 
    return count;
@@ -825,7 +825,7 @@ VNetUserIfWrite(VNetPort    *port, // IN
  *
  *      XXX
  *
- * Results: 
+ * Results:
  *      0 on success
  *      -errno on failure
  *
@@ -848,8 +848,8 @@ VNetUserIfIoctl(VNetPort      *port,  // IN
       return -EINVAL;
    case SIOCSETNOTIFY2:
 #ifdef VMX86_SERVER
-      /* 
-       * This ioctl always return failure on ESX since we cannot map pages into 
+      /*
+       * This ioctl always return failure on ESX since we cannot map pages into
        * the console os that are from the VMKernel address space which  was the
        * only case we used this.
        */
@@ -892,18 +892,18 @@ VNetUserIfIoctl(VNetPort      *port,  // IN
       break;
 
    case SIOCSIFFLAGS:
-      /* 
-       * Drain queue when interface is no longer active. We drain the queue to 
+      /*
+       * Drain queue when interface is no longer active. We drain the queue to
        * avoid having old packets delivered to the guest when reneabled.
        */
-      
+
       if (!UP_AND_RUNNING(userIf->port.flags)) {
          struct sk_buff *skb;
-         
+
          while ((skb = skb_dequeue(&userIf->packetQueue)) != NULL) {
             dev_kfree_skb(skb);
          }
-         
+
          if (userIf->pollPtr) {
             /* Clear the pending bit as no packets are pending at this point. */
             *userIf->pollPtr &= ~userIf->pollMask;
@@ -913,11 +913,11 @@ VNetUserIfIoctl(VNetPort      *port,  // IN
    case SIOCINJECTLINKSTATE:
       {
          uint8 linkUpFromUser;
-         if (copy_from_user(&linkUpFromUser, (void *)ioarg, 
+         if (copy_from_user(&linkUpFromUser, (void *)ioarg,
                             sizeof linkUpFromUser)) {
             return -EFAULT;
          }
-         
+
          if (linkUpFromUser != 0 && linkUpFromUser != 1) {
             return -EINVAL;
          }
@@ -929,7 +929,7 @@ VNetUserIfIoctl(VNetPort      *port,  // IN
       return -ENOIOCTLCMD;
       break;
    }
-   
+
    return 0;
 }
 
@@ -941,7 +941,7 @@ VNetUserIfIoctl(VNetPort      *port,  // IN
  *
  *      The virtual network's file poll operation.
  *
- * Results: 
+ * Results:
  *      Return POLLIN if success, else sleep and return 0.
  *      FIXME: Should not we always return POLLOUT?
  *
@@ -957,7 +957,7 @@ VNetUserIfPoll(VNetPort     *port, // IN
                poll_table   *wait) // IN
 {
    VNetUserIF *userIf = (VNetUserIF*)port->jack.private;
-   
+
    poll_wait(filp, &userIf->waitQueue, wait);
    if (!skb_queue_empty(&userIf->packetQueue)) {
       return POLLIN;
@@ -972,8 +972,8 @@ VNetUserIfPoll(VNetPort     *port, // IN
  * VNetUserIfSetUplinkState --
  *
  *      Sends link state change event.
- * 
- * Results: 
+ *
+ * Results:
  *      0 on success, errno on failure.
  *
  * Side effects:
@@ -1015,7 +1015,7 @@ VNetUserIfSetUplinkState(VNetPort *port, uint8 linkUp)
    event.header.eventId = 0;
    event.header.classSet = VNET_EVENT_CLASS_UPLINK;
    event.header.type = VNET_EVENT_TYPE_LINK_STATE;
-   /* 
+   /*
     * XXX kind of a hack, vmx will coalesce linkup/down if they come from the
     * same adapter.
     */
@@ -1027,7 +1027,7 @@ VNetUserIfSetUplinkState(VNetPort *port, uint8 linkUp)
               "failed (%d)\n", userIf->port.id, retval));
    }
 
-   LOG(0, (KERN_NOTICE "userif-%d: sent link %s event.", 
+   LOG(0, (KERN_NOTICE "userif-%d: sent link %s event.",
         userIf->port.id, linkUp?"up":"down"));
 
    return retval;
@@ -1040,8 +1040,8 @@ VNetUserIfSetUplinkState(VNetPort *port, uint8 linkUp)
  *
  *      Create a user level port to the wonderful world of virtual
  *      networking.
- * 
- * Results: 
+ *
+ * Results:
  *      Errno. Also returns an allocated port to connect to,
  *      NULL on error.
  *
@@ -1057,7 +1057,7 @@ VNetUserIf_Create(VNetPort **ret) // OUT
    VNetUserIF *userIf;
    static unsigned id = 0;
    int retval;
-   
+
    userIf = kmalloc(sizeof *userIf, GFP_USER);
    if (!userIf) {
       return -ENOMEM;
@@ -1066,7 +1066,7 @@ VNetUserIf_Create(VNetPort **ret) // OUT
    /*
     * Initialize fields.
     */
-   
+
    userIf->port.id = id++;
 
    userIf->port.jack.peer = NULL;
@@ -1095,8 +1095,8 @@ VNetUserIf_Create(VNetPort **ret) // OUT
    /*
     * Make proc entry for this jack.
     */
-   
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
    retval = VNetProc_MakeEntry(userIf->port.jack.name, S_IFREG,
                                &userIf->port.jack.procEntry)
 #else
@@ -1110,7 +1110,7 @@ VNetUserIf_Create(VNetPort **ret) // OUT
          kfree(userIf);
          return retval;
       }
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
    } else {
       userIf->port.jack.procEntry->read_proc = VNetUserIfProcRead;
       userIf->port.jack.procEntry->data = userIf;
@@ -1120,7 +1120,7 @@ VNetUserIf_Create(VNetPort **ret) // OUT
    /*
     * Rest of fields.
     */
-   
+
    userIf->port.flags = IFF_RUNNING;
 
    memset(userIf->port.paddr, 0, sizeof userIf->port.paddr);
@@ -1133,12 +1133,12 @@ VNetUserIf_Create(VNetPort **ret) // OUT
    userIf->port.fileOpWrite = VNetUserIfWrite;
    userIf->port.fileOpIoctl = VNetUserIfIoctl;
    userIf->port.fileOpPoll = VNetUserIfPoll;
-   
+
    skb_queue_head_init(&(userIf->packetQueue));
    init_waitqueue_head(&userIf->waitQueue);
 
    memset(&userIf->stats, 0, sizeof userIf->stats);
-   
+
    *ret = (VNetPort*)userIf;
    return 0;
 }
diff --git a/vmnet-only/vnetInt.h b/vmnet-only/vnetInt.h
index a4a1f16..e0c94f6 100644
--- a/vmnet-only/vnetInt.h
+++ b/vmnet-only/vnetInt.h
@@ -44,7 +44,7 @@
 #define LOGLEVEL 1
 #endif
 #endif
-     
+
 #define LOGLEVEL 1
 
 #if LOGLEVEL >= 0
@@ -67,7 +67,7 @@
 #define NETDEV_UP_AND_RUNNING(dev) ((((dev)->flags) & IFF_UP) && netif_running(dev))
 
 /*
- * Misc defines 
+ * Misc defines
  */
 
 #define NULL_TERMINATE_STRING(a) (a)[sizeof (a) - 1] = '\0'
@@ -80,7 +80,7 @@
 #define VNET_MAJOR_NUMBER      119
 
 /* We support upto 32 adapters with LSP + DHCP + NAT + netif + sniffer */
-#define NUM_JACKS_PER_HUB      68 
+#define NUM_JACKS_PER_HUB      68
 #define VNET_MAX_QLEN          128
 
 #define VNET_NUM_IPBASED_MACS  64
@@ -117,7 +117,7 @@ struct VNetJack {
    void          *private;     // private field for containing object
    int            index;       // private field for containing object
    VNetProcEntry *procEntry;   // private field for containing object
-   
+
    void         (*free)(VNetJack *this);
    void         (*rcv)(VNetJack *this, struct sk_buff *skb);
    Bool         (*cycleDetect)(VNetJack *this, int generation);
@@ -140,15 +140,15 @@ struct VNetPort {
    uint8       ladrf[VNET_LADRF_LEN];
    uint8       exactFilter[VNET_MAX_EXACT_FILTER_LEN][ETHER_ADDR_LEN];
    uint32      exactFilterLen;
-   
+
    VNetPort   *next;
-   
+
    int       (*fileOpRead)(VNetPort *this, struct file *filp,
                            char *buf, size_t count);
    int       (*fileOpWrite)(VNetPort *this, struct file *filp,
                             const char *buf, size_t count);
    int       (*fileOpIoctl)(VNetPort *this, struct file *filp,
-                            unsigned int iocmd, unsigned long ioarg);   
+                            unsigned int iocmd, unsigned long ioarg);
    int       (*fileOpPoll)(VNetPort *this, struct file *filp,
                            poll_table *wait);
 };
@@ -171,7 +171,7 @@ VNetJack *VNetDisconnect(VNetJack *jack);
 
 void VNetSend(const VNetJack *jack, struct sk_buff *skb);
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int VNetProc_MakeEntry(char *name, int mode,
                        VNetProcEntry **ret);
 #else
@@ -183,7 +183,7 @@ int VNetProc_MakeEntryOps(char *name, int mode,
 
 void VNetProc_RemoveEntry(VNetProcEntry *node);
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int VNetPrintJack(const VNetJack *jack, char *buf);
 #else
 void VNetPrintJack(const VNetJack *jack, struct seq_file *seqf);
@@ -193,21 +193,21 @@ int VNet_MakeMACAddress(VNetPort *port);
 
 int VNetSetMACUnique(VNetPort *port, const uint8 mac[ETH_ALEN]);
 
-     
+
 /*
  *  Utility functions
  */
 
 extern const uint8 allMultiFilter[VNET_LADRF_LEN];
 extern const uint8 broadcast[ETH_ALEN];
- 
-Bool VNetPacketMatch(const uint8 *destAddr, const uint8 *ifAddr, 
+
+Bool VNetPacketMatch(const uint8 *destAddr, const uint8 *ifAddr,
                      const uint8 *exactFilter, const uint32 exactFilterLen,
 		     const uint8 *ladrf, uint32 flags);
 
 Bool VNetCycleDetectIf(const char *name, int generation);
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int VNetPrintPort(const VNetPort *port, char *buf);
 #else
 void VNetPrintPort(const VNetPort *port, struct seq_file *seqf);
@@ -231,7 +231,7 @@ extern void VNetProc_Cleanup(void);
  *
  *      Perform the cycle detect alogorithm for this generation.
  *
- * Results: 
+ * Results:
  *      TRUE if a cycle was detected, FALSE otherwise.
  *
  * Side effects:
@@ -242,7 +242,7 @@ extern void VNetProc_Cleanup(void);
 
 static INLINE Bool
 VNetCycleDetect(VNetJack *jack,       // IN: jack
-                int       generation) // IN: 
+                int       generation) // IN:
 {
    if (jack && jack->cycleDetect) {
       return jack->cycleDetect(jack, generation);
@@ -260,7 +260,7 @@ VNetCycleDetect(VNetJack *jack,       // IN: jack
  *      Notify a jack that the number of connected ports has changed.
  *	vnetStructureSemaphore must be held.
  *
- * Results: 
+ * Results:
  *      None.
  *
  * Side effects:
-- 
2.0.0


From ea94988e2ac02e6dcc98a497dfdd068d5bd00cf2 Mon Sep 17 00:00:00 2001
From: Adrian Bacircea <adrian.bacircea@gmail.com>
Date: Tue, 28 Jan 2014 10:31:36 +0200
Subject: [PATCH 03/10] patch for linux 3.13

---
 vmnet-only/filter.c | 26 +++++++++++++++++---------
 1 file changed, 17 insertions(+), 9 deletions(-)

diff --git a/vmnet-only/filter.c b/vmnet-only/filter.c
index b1f4625..cb3510e 100644
--- a/vmnet-only/filter.c
+++ b/vmnet-only/filter.c
@@ -96,7 +96,7 @@ static DEFINE_SPINLOCK(activeRuleLock);
 
 /*
  * Logging.
- * 
+ *
  * All logging for development build uses LOG(2, (KERN_INFO ...)) because the default
  * log level is set to 1 (vnetInt.h). All ACE logging, i.e. policy driven logging, uses
  * printk(KERN_INFO ...).
@@ -203,7 +203,11 @@ ForwardPacket(uint16 action,  // IN: reason code
 #endif
 
 static unsigned int
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0)
 VNetFilterHookFn(unsigned int hooknum,                 // IN:
+#else
+VNetFilterHookFn(const struct nf_hook_ops *ops         // IN:
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0) */
 #ifdef VMW_NFHOOK_USES_SKB
                  struct sk_buff *skb,                  // IN:
 #else
@@ -252,7 +256,11 @@ VNetFilterHookFn(unsigned int hooknum,                 // IN:
 
    /* When the host transmits, hooknum is VMW_NF_INET_POST_ROUTING. */
    /* When the host receives, hooknum is VMW_NF_INET_LOCAL_IN. */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0)
    transmit = (hooknum == VMW_NF_INET_POST_ROUTING);
+#else
+   transmit = (opt->hooknum == VMW_NF_INET_POST_ROUTING);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0) */
 
    packetHeader = compat_skb_network_header(skb);
    ip = (struct iphdr*)packetHeader;
@@ -284,8 +292,8 @@ VNetFilterHookFn(unsigned int hooknum,                 // IN:
        * know why, but in such cases, this calculation will lead to a negative
        * packetLength, and the packet to be dropped.
        */
-      packetLength = skb->len - 
-                     (compat_skb_network_header(skb) - compat_skb_mac_header(skb)) - 
+      packetLength = skb->len -
+                     (compat_skb_network_header(skb) - compat_skb_mac_header(skb)) -
                      (ip->ihl << 2);
    }
 
@@ -1418,10 +1426,10 @@ out_error:
          LOG(2, (KERN_INFO "add filter rule IPv6 not supported\n"));
          retval = -EPROTONOSUPPORT;
          goto out_unlock;
-         
+
       case VNET_FILTER_CMD_SET_LOG_LEVEL: {
          VNet_SetLogLevel setLogLevel;
-         
+
          if (copy_from_user(&setLogLevel, (void *)ioarg, sizeof setLogLevel)) {
             retval = -EFAULT;
          } else if (setLogLevel.header.len != sizeof setLogLevel) {
@@ -1518,17 +1526,17 @@ LogPacket(uint16 action,  // IN: reason for packet drop/forward
 {
    char packet[(LOGPACKET_HEADER_LEN + LOGPACKET_DATA_LEN) * 3 + 1];
    int i, n;
-   
+
    /* something to do? */
    if (VNET_FILTER_LOGLEVEL_VERBOSE > logLevel) {
       return;
    }
-   
+
    /* cap packet length */
    if (length > LOGPACKET_DATA_LEN) {
       length = LOGPACKET_DATA_LEN;
    }
-   
+
    /* build packet string */
    n = 0;
    if (header) {
@@ -1541,7 +1549,7 @@ LogPacket(uint16 action,  // IN: reason for packet drop/forward
       sprintf(&packet[n], "%02x ", ((uint8 *)data)[i]);
       n += 3;
    }
-   
+
    /* log packet */
    printk(KERN_INFO "packet %s: %s\n", drop ? "dropped" : "forwarded", packet);
 }
-- 
2.0.0


From 01d20ac67561ed9808d212c196b7f38e25b975bc Mon Sep 17 00:00:00 2001
From: Adrian Bacircea <adrian.bacircea@gmail.com>
Date: Tue, 28 Jan 2014 10:49:52 +0200
Subject: [PATCH 04/10] fix patch for 3.13

---
 vmnet-only/filter.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/vmnet-only/filter.c b/vmnet-only/filter.c
index cb3510e..165d916 100644
--- a/vmnet-only/filter.c
+++ b/vmnet-only/filter.c
@@ -206,7 +206,7 @@ static unsigned int
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0)
 VNetFilterHookFn(unsigned int hooknum,                 // IN:
 #else
-VNetFilterHookFn(const struct nf_hook_ops *ops         // IN:
+VNetFilterHookFn(const struct nf_hook_ops *ops,        // IN:
 #endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0) */
 #ifdef VMW_NFHOOK_USES_SKB
                  struct sk_buff *skb,                  // IN:
-- 
2.0.0


From ff78307620bc65d32c2f4deb7b337b3fda46042c Mon Sep 17 00:00:00 2001
From: Adrian Bacircea <adrian.bacircea@gmail.com>
Date: Tue, 28 Jan 2014 10:53:13 +0200
Subject: [PATCH 05/10] further fixing of the patch for 3.13

---
 vmnet-only/filter.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/vmnet-only/filter.c b/vmnet-only/filter.c
index 165d916..68515e8 100644
--- a/vmnet-only/filter.c
+++ b/vmnet-only/filter.c
@@ -259,7 +259,7 @@ VNetFilterHookFn(const struct nf_hook_ops *ops,        // IN:
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0)
    transmit = (hooknum == VMW_NF_INET_POST_ROUTING);
 #else
-   transmit = (opt->hooknum == VMW_NF_INET_POST_ROUTING);
+   transmit = (ops->hooknum == VMW_NF_INET_POST_ROUTING);
 #endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0) */
 
    packetHeader = compat_skb_network_header(skb);
-- 
2.0.0


From 79fab20449b1f68bff6e4efc674fc87f08f9f7a3 Mon Sep 17 00:00:00 2001
From: Adrian Bacircea <adrian.bacircea@gmail.com>
Date: Wed, 2 Apr 2014 20:18:18 +0300
Subject: [PATCH 06/10] Initial commit for linux 3.14 compatibility

---
 vmblock-only/linux/inode.c        | 2 +-
 vmci-only/linux/vmciKernelIf.c    | 2 +-
 vmci-only/shared/vmci_kernel_if.h | 5 +++++
 vsock-only/linux/af_vsock.h       | 4 ++++
 4 files changed, 11 insertions(+), 2 deletions(-)

diff --git a/vmblock-only/linux/inode.c b/vmblock-only/linux/inode.c
index b56fc85..aaa554c 100644
--- a/vmblock-only/linux/inode.c
+++ b/vmblock-only/linux/inode.c
@@ -144,7 +144,7 @@ InodeOpLookup(struct inode *dir,      // IN: parent directory's inode
    inode->i_size = INODE_TO_IINFO(inode)->nameLen;
    inode->i_version = 1;
    inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
-   inode->i_uid = inode->i_gid = 0;
+   inode->i_uid.val = inode->i_gid.val = 0;
    inode->i_op = &LinkInodeOps;
 
    d_add(dentry, inode);
diff --git a/vmci-only/linux/vmciKernelIf.c b/vmci-only/linux/vmciKernelIf.c
index 03b567d..3997bd8 100644
--- a/vmci-only/linux/vmciKernelIf.c
+++ b/vmci-only/linux/vmciKernelIf.c
@@ -418,7 +418,7 @@ int VMCIHost_CompareUser(VMCIHostUser *user1,
       return VMCI_ERROR_INVALID_ARGS;
    }
 
-   if (*user1 == *user2) {
+   if (user1->val == user2->val) {
       return VMCI_SUCCESS;
    } else {
       return VMCI_ERROR_GENERIC;
diff --git a/vmci-only/shared/vmci_kernel_if.h b/vmci-only/shared/vmci_kernel_if.h
index 662ce5d..32ab9d8 100644
--- a/vmci-only/shared/vmci_kernel_if.h
+++ b/vmci-only/shared/vmci_kernel_if.h
@@ -110,7 +110,12 @@
   typedef wait_queue_head_t VMCIEvent;
   typedef struct semaphore VMCIMutex;
   typedef PPN *VMCIPpnList; /* List of PPNs in produce/consume queue. */
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 13, 0)
   typedef uid_t VMCIHostUser;
+#else /* LINUX_VERSION_CODE > KERNEL_VERSION(3, 13) */
+  typedef kuid_t VMCIHostUser;
+#endif /* LINUX_VERSION_CODE <= KERNEL_VERSION(3, 13) */
+
   typedef VA64 VMCIQPGuestMem;
 #elif defined(__APPLE__)
   typedef IOLock *VMCILock;
diff --git a/vsock-only/linux/af_vsock.h b/vsock-only/linux/af_vsock.h
index 30600ae..c2b544b 100644
--- a/vsock-only/linux/af_vsock.h
+++ b/vsock-only/linux/af_vsock.h
@@ -60,7 +60,11 @@ typedef struct VSockVmciSock {
    Bool trusted;
    Bool cachedPeerAllowDgram; /* Dgram communication allowed to cached peer? */
    VMCIId cachedPeer; /* Context ID of last dgram destination check. */
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 13, 0)
    uid_t owner;
+#else /* LINUX_VERSION_CODE > KERNEL_VERSION(3, 13) */
+   kuid_t owner;
+#endif /* LINUX_VERSION_CODE <= KERNEL_VERSION(3, 13) */
    VMCIHandle dgHandle;           /* For SOCK_DGRAM only. */
    /* Rest are SOCK_STREAM only. */
    VMCIHandle qpHandle;
-- 
2.0.0


From 85b495ae66a88f91c21620fa9612a7402d785d0b Mon Sep 17 00:00:00 2001
From: Adrian Bacircea <adrian.bacircea@gmail.com>
Date: Wed, 2 Apr 2014 20:32:05 +0300
Subject: [PATCH 07/10] Fix undefined getname symbol

---
 vmblock-only/linux/control.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/vmblock-only/linux/control.c b/vmblock-only/linux/control.c
index a245793..32d9139 100644
--- a/vmblock-only/linux/control.c
+++ b/vmblock-only/linux/control.c
@@ -291,7 +291,11 @@ ExecuteBlockOp(const char __user *buf,                // IN: buffer with name
    int i;
    int retval;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+   name = (char*)(getname(buf)->name);
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0) */
    name = getname(buf);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0) */
    if (IS_ERR(name)) {
       return PTR_ERR(name);
    }
-- 
2.0.0


From a1c1e856217b53dacd92a0943047622436906a8d Mon Sep 17 00:00:00 2001
From: Adrian Bacircea <adrian.bacircea@gmail.com>
Date: Wed, 2 Apr 2014 21:18:12 +0300
Subject: [PATCH 08/10] Really fix getname undefined symbol

---
 vmblock-only/linux/control.c | 27 ++++++++++++++++++++++++---
 1 file changed, 24 insertions(+), 3 deletions(-)

diff --git a/vmblock-only/linux/control.c b/vmblock-only/linux/control.c
index 32d9139..54e020d 100644
--- a/vmblock-only/linux/control.c
+++ b/vmblock-only/linux/control.c
@@ -287,18 +287,33 @@ ExecuteBlockOp(const char __user *buf,                // IN: buffer with name
                int (*blockOp)(const char *filename,   // IN: block operation
                               const os_blocker_id_t blocker))
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+   struct filename *result;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0) */
    char *name;
    int i;
    int retval;
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
-   name = (char*)(getname(buf)->name);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+#define EMBEDDED_NAME_MAX (PATH_MAX - sizeof(struct filename))
+   result = NULL; /* get rid of compiler warning */
+   name = __getname();
+   if (IS_ERR(name)) {
+      return PTR_ERR(name);
+   }
+   strncpy_from_user(name, buf, EMBEDDED_NAME_MAX);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+   result = getname(buf);
+   if (IS_ERR(result)) {
+      return PTR_ERR(result);
+   }
+   name = result->name;
 #else /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0) */
    name = getname(buf);
-#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0) */
    if (IS_ERR(name)) {
       return PTR_ERR(name);
    }
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0) */
 
    for (i = strlen(name) - 1; i >= 0 && name[i] == '/'; i--) {
       name[i] = '\0';
@@ -306,7 +321,13 @@ ExecuteBlockOp(const char __user *buf,                // IN: buffer with name
 
    retval = i < 0 ? -EINVAL : blockOp(name, blocker);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
    __putname(name);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+   __putname(result);
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0) */
+    putname(name);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0) */
 
    return retval;
 }
-- 
2.0.0


From c509206c650cbb1482e61064d6121a34784d51f3 Mon Sep 17 00:00:00 2001
From: Cosmin Stanescu <cosmin90stanescu@gmail.com>
Date: Sun, 15 Jun 2014 02:59:34 +0300
Subject: [PATCH 09/10] Fix code for kernel 3.15

---
 vmblock-only/linux/inode.c      | 6 +++++-
 vsock-only/linux/notify.c       | 4 ++++
 vsock-only/linux/notifyQState.c | 8 ++++++++
 3 files changed, 17 insertions(+), 1 deletion(-)

diff --git a/vmblock-only/linux/inode.c b/vmblock-only/linux/inode.c
index aaa554c..a89d5ec 100644
--- a/vmblock-only/linux/inode.c
+++ b/vmblock-only/linux/inode.c
@@ -186,7 +186,11 @@ InodeOpReadlink(struct dentry *dentry,  // IN : dentry of symlink
       return -EINVAL;
    }
 
-   return vfs_readlink(dentry, buffer, buflen, iinfo->name);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0)
+   return vfs_readlink(dentry, buffer, buflen, info->name);
+#else
+   return readlink_copy(buffer, buflen, info->name);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0) */
 }
 
 
diff --git a/vsock-only/linux/notify.c b/vsock-only/linux/notify.c
index 755b037..e866566 100644
--- a/vsock-only/linux/notify.c
+++ b/vsock-only/linux/notify.c
@@ -516,7 +516,11 @@ VSockVmciHandleWrote(struct sock *sk,            // IN
    PKT_FIELD(vsk, sentWaitingRead) = FALSE;
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0)
    sk->sk_data_ready(sk, 0);
+#else
+   sk->sk_data_ready(sk);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0) */
 }
 
 
diff --git a/vsock-only/linux/notifyQState.c b/vsock-only/linux/notifyQState.c
index 0d53c81..69326a5 100644
--- a/vsock-only/linux/notifyQState.c
+++ b/vsock-only/linux/notifyQState.c
@@ -164,7 +164,11 @@ VSockVmciHandleWrote(struct sock *sk,            // IN
                      struct sockaddr_vm *dst,    // IN: unused
                      struct sockaddr_vm *src)    // IN: unused
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0)
    sk->sk_data_ready(sk, 0);
+#else
+   sk->sk_data_ready(sk);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0) */
 }
 
 
@@ -566,7 +570,11 @@ VSockVmciNotifyPktRecvPostDequeue(struct sock *sk,               // IN
       }
 
       /* See the comment in VSockVmciNotifyPktSendPostEnqueue */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0)
       sk->sk_data_ready(sk, 0);
+#else
+      sk->sk_data_ready(sk);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0) */
    }
 
    return err;
-- 
2.0.0


From f55451c1cc57e8a9531834a7dd1a2496085139b3 Mon Sep 17 00:00:00 2001
From: Cosmin Stanescu <cosmin90stanescu@gmail.com>
Date: Sun, 15 Jun 2014 03:00:35 +0300
Subject: [PATCH 10/10] Fix typo

---
 vmblock-only/linux/inode.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/vmblock-only/linux/inode.c b/vmblock-only/linux/inode.c
index a89d5ec..e4f0ce4 100644
--- a/vmblock-only/linux/inode.c
+++ b/vmblock-only/linux/inode.c
@@ -187,9 +187,9 @@ InodeOpReadlink(struct dentry *dentry,  // IN : dentry of symlink
    }
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0)
-   return vfs_readlink(dentry, buffer, buflen, info->name);
+   return vfs_readlink(dentry, buffer, buflen, iinfo->name);
 #else
-   return readlink_copy(buffer, buflen, info->name);
+   return readlink_copy(buffer, buflen, iinfo->name);
 #endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0) */
 }
 
-- 
2.0.0

